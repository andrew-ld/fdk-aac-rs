/* automatically generated by rust-bindgen */

pub const SHORT_BITS: u32 = 16;
pub const CHAR_BITS: u32 = 8;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const WAV_BITS: u32 = 16;
pub const SAMPLE_BITS: u32 = 16;
pub const ALIGNMENT_DEFAULT: u32 = 8;
pub const ALIGNMENT_EXTRES: u32 = 8;
pub const M_PI: f64 = 3.141592653589793;
pub const FDK_EXITCODE_OK: u32 = 0;
pub const FDK_EXITCODE_USAGE: u32 = 64;
pub const FDK_EXITCODE_DATAERROR: u32 = 65;
pub const FDK_EXITCODE_NOINPUT: u32 = 66;
pub const FDK_EXITCODE_UNAVAILABLE: u32 = 69;
pub const FDK_EXITCODE_SOFTWARE: u32 = 70;
pub const FDK_EXITCODE_CANTCREATE: u32 = 73;
pub const FDK_EXITCODE_IOERROR: u32 = 74;
pub const FDK_MAX_OVERLAYS: u32 = 8;
pub const AC_ER_VCB11: u32 = 1;
pub const AC_ER_RVLC: u32 = 2;
pub const AC_ER_HCR: u32 = 4;
pub const AC_SCALABLE: u32 = 8;
pub const AC_ELD: u32 = 16;
pub const AC_LD: u32 = 32;
pub const AC_ER: u32 = 64;
pub const AC_BSAC: u32 = 128;
pub const AC_USAC: u32 = 256;
pub const AC_RSV603DA: u32 = 512;
pub const AC_HDAAC: u32 = 1024;
pub const AC_RSVD50: u32 = 16384;
pub const AC_SBR_PRESENT: u32 = 32768;
pub const AC_SBRCRC: u32 = 65536;
pub const AC_PS_PRESENT: u32 = 131072;
pub const AC_MPS_PRESENT: u32 = 262144;
pub const AC_DRM: u32 = 524288;
pub const AC_INDEP: u32 = 1048576;
pub const AC_MPEGD_RES: u32 = 2097152;
pub const AC_SAOC_PRESENT: u32 = 4194304;
pub const AC_DAB: u32 = 8388608;
pub const AC_ELD_DOWNSCALE: u32 = 16777216;
pub const AC_LD_MPS: u32 = 33554432;
pub const AC_DRC_PRESENT: u32 = 67108864;
pub const AC_USAC_SCFGI3: u32 = 134217728;
pub const AC_CM_DET_CFG_CHANGE: u32 = 1;
pub const AC_CM_ALLOC_MEM: u32 = 2;
pub const AC_EL_USAC_TW: u32 = 1;
pub const AC_EL_USAC_NOISE: u32 = 2;
pub const AC_EL_USAC_ITES: u32 = 4;
pub const AC_EL_USAC_PVC: u32 = 8;
pub const AC_EL_USAC_MPS212: u32 = 16;
pub const AC_EL_USAC_LFE: u32 = 32;
pub const AC_EL_USAC_CP_POSSIBLE: u32 = 64;
pub const AC_EL_ENHANCED_NOISE: u32 = 128;
pub const AC_EL_IGF_AFTER_TNS: u32 = 256;
pub const AC_EL_IGF_INDEP_TILING: u32 = 512;
pub const AC_EL_IGF_USE_ENF: u32 = 1024;
pub const AC_EL_FULLBANDLPD: u32 = 2048;
pub const AC_EL_LPDSTEREOIDX: u32 = 4096;
pub const AC_EL_LFE: u32 = 8192;
pub const CC_MPEG_ID: u32 = 1048576;
pub const CC_IS_BASELAYER: u32 = 2097152;
pub const CC_PROTECTION: u32 = 4194304;
pub const CC_SBR: u32 = 8388608;
pub const CC_SBRCRC: u32 = 65536;
pub const CC_SAC: u32 = 131072;
pub const CC_RVLC: u32 = 16777216;
pub const CC_VCB11: u32 = 33554432;
pub const CC_HCR: u32 = 67108864;
pub const CC_PSEUDO_SURROUND: u32 = 134217728;
pub const CC_USAC_NOISE: u32 = 268435456;
pub const CC_USAC_TW: u32 = 536870912;
pub const CC_USAC_HBE: u32 = 1073741824;
pub const USAC_ID_BIT: u32 = 16;
pub const EXT_ID_BITS: u32 = 4;
pub const CAPF_AAC_LC: u32 = 1;
pub const CAPF_ER_AAC_LD: u32 = 2;
pub const CAPF_ER_AAC_SCAL: u32 = 4;
pub const CAPF_ER_AAC_LC: u32 = 8;
pub const CAPF_AAC_480: u32 = 16;
pub const CAPF_AAC_512: u32 = 32;
pub const CAPF_AAC_960: u32 = 64;
pub const CAPF_AAC_1024: u32 = 128;
pub const CAPF_AAC_HCR: u32 = 256;
pub const CAPF_AAC_VCB11: u32 = 512;
pub const CAPF_AAC_RVLC: u32 = 1024;
pub const CAPF_AAC_MPEG4: u32 = 2048;
pub const CAPF_AAC_DRC: u32 = 4096;
pub const CAPF_AAC_CONCEALMENT: u32 = 8192;
pub const CAPF_AAC_DRM_BSFORMAT: u32 = 16384;
pub const CAPF_ER_AAC_ELD: u32 = 32768;
pub const CAPF_ER_AAC_BSAC: u32 = 65536;
pub const CAPF_AAC_ELD_DOWNSCALE: u32 = 262144;
pub const CAPF_AAC_USAC_LP: u32 = 1048576;
pub const CAPF_AAC_USAC: u32 = 2097152;
pub const CAPF_ER_AAC_ELDV2: u32 = 8388608;
pub const CAPF_AAC_UNIDRC: u32 = 16777216;
pub const CAPF_ADTS: u32 = 1;
pub const CAPF_ADIF: u32 = 2;
pub const CAPF_LATM: u32 = 4;
pub const CAPF_LOAS: u32 = 8;
pub const CAPF_RAWPACKETS: u32 = 16;
pub const CAPF_DRM: u32 = 32;
pub const CAPF_RSVD50: u32 = 64;
pub const CAPF_SBR_LP: u32 = 1;
pub const CAPF_SBR_HQ: u32 = 2;
pub const CAPF_SBR_DRM_BS: u32 = 4;
pub const CAPF_SBR_CONCEALMENT: u32 = 8;
pub const CAPF_SBR_DRC: u32 = 16;
pub const CAPF_SBR_PS_MPEG: u32 = 32;
pub const CAPF_SBR_PS_DRM: u32 = 64;
pub const CAPF_SBR_ELD_DOWNSCALE: u32 = 128;
pub const CAPF_SBR_HBEHQ: u32 = 256;
pub const CAPF_DMX_BLIND: u32 = 1;
pub const CAPF_DMX_PCE: u32 = 2;
pub const CAPF_DMX_ARIB: u32 = 4;
pub const CAPF_DMX_DVB: u32 = 8;
pub const CAPF_DMX_CH_EXP: u32 = 16;
pub const CAPF_DMX_6_CH: u32 = 32;
pub const CAPF_DMX_8_CH: u32 = 64;
pub const CAPF_DMX_24_CH: u32 = 128;
pub const CAPF_LIMITER: u32 = 8192;
pub const CAPF_MPS_STD: u32 = 1;
pub const CAPF_MPS_LD: u32 = 2;
pub const CAPF_MPS_USAC: u32 = 4;
pub const CAPF_MPS_HQ: u32 = 16;
pub const CAPF_MPS_LP: u32 = 32;
pub const CAPF_MPS_BLIND: u32 = 64;
pub const CAPF_MPS_BINAURAL: u32 = 128;
pub const CAPF_MPS_2CH_OUT: u32 = 256;
pub const CAPF_MPS_6CH_OUT: u32 = 512;
pub const CAPF_MPS_8CH_OUT: u32 = 1024;
pub const CAPF_MPS_1CH_IN: u32 = 4096;
pub const CAPF_MPS_2CH_IN: u32 = 8192;
pub const CAPF_MPS_6CH_IN: u32 = 16384;
pub const AACDEC_CONCEAL: u32 = 1;
pub const AACDEC_FLUSH: u32 = 2;
pub const AACDEC_INTR: u32 = 4;
pub const AACDEC_CLRHIST: u32 = 8;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
#[doc = " \\var  SCHAR"]
#[doc = "        Data type representing at least 1 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing at least 1 byte unsigned integer on all"]
#[doc = " supported platforms."]
#[doc = "        Data type representing at least 4 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing at least 4 byte unsigned integer on all"]
#[doc = " supported platforms."]
#[doc = "        Data type representing 4 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 4 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 2 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 2 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 8 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 8 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Number of bits the data type short represents. sizeof() is not suited"]
#[doc = " to get this info, because a byte is not always defined as 8 bits."]
#[doc = "        Number of bits the data type char represents. sizeof() is not suited"]
#[doc = " to get this info, because a byte is not always defined as 8 bits."]
#[doc = "        Data type representing the width of input and output PCM samples."]
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type SHORT = ::std::os::raw::c_short;
pub type USHORT = ::std::os::raw::c_ushort;
pub type SCHAR = ::std::os::raw::c_schar;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINT64 = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type INT_PCM = SHORT;
pub const MEMORY_SECTION_SECT_DATA_L1: MEMORY_SECTION = 8192;
pub const MEMORY_SECTION_SECT_DATA_L2: MEMORY_SECTION = 8193;
pub const MEMORY_SECTION_SECT_DATA_L1_A: MEMORY_SECTION = 8194;
pub const MEMORY_SECTION_SECT_DATA_L1_B: MEMORY_SECTION = 8195;
pub const MEMORY_SECTION_SECT_CONSTDATA_L1: MEMORY_SECTION = 8196;
pub const MEMORY_SECTION_SECT_DATA_EXTERN: MEMORY_SECTION = 16384;
pub const MEMORY_SECTION_SECT_CONSTDATA_EXTERN: MEMORY_SECTION = 16385;
#[doc = " Identifiers for various memory locations. They are used along with memory"]
#[doc = " allocation functions like FDKcalloc_L() to specify the requested memory's"]
#[doc = " location."]
pub type MEMORY_SECTION = u32;
extern "C" {
    pub fn FDKprintf(szFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn FDKprintfErr(szFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Wrapper for <stdio.h>'s getchar()."]
    pub fn FDKgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FDKfprintf(
        stream: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> INT;
}
extern "C" {
    pub fn FDKsprintf(
        str: *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> INT;
}
extern "C" {
    pub fn FDKstrchr(s: *mut ::std::os::raw::c_char, c: INT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FDKstrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FDKstrcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FDKstrncpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: UINT,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FDKcalloc(n: UINT, size: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FDKmalloc(size: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FDKfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Allocate and clear an aligned memory area. Use FDKafree() instead of"]
    #[doc = " FDKfree() for these memory areas."]
    #[doc = ""]
    #[doc = " \\param size       Size of requested memory in bytes."]
    #[doc = " \\param alignment  Alignment of requested memory in bytes."]
    #[doc = " \\return           Pointer to allocated memory."]
    pub fn FDKaalloc(size: UINT, alignment: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Free an aligned memory area."]
    #[doc = ""]
    #[doc = " \\param ptr  Pointer to be freed."]
    pub fn FDKafree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Allocate memory in a specific memory section."]
    #[doc = "  Requests can be made for internal or external memory. If internal memory is"]
    #[doc = "  requested, FDKcalloc_L() first tries to use L1 memory, which sizes are"]
    #[doc = " defined by ::DATA_L1_A_SIZE and ::DATA_L1_B_SIZE. If no L1 memory is"]
    #[doc = " available, then FDKcalloc_L() tries to use L2 memory. If that fails as well,"]
    #[doc = " the requested memory is allocated at an extern location using the fallback"]
    #[doc = " FDKcalloc()."]
    #[doc = ""]
    #[doc = " \\param n     See MSDN documentation on calloc()."]
    #[doc = " \\param size  See MSDN documentation on calloc()."]
    #[doc = " \\param s     Memory section."]
    #[doc = " \\return      See MSDN documentation on calloc()."]
    pub fn FDKcalloc_L(n: UINT, size: UINT, s: MEMORY_SECTION) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Allocate aligned memory in a specific memory section."]
    #[doc = "  See FDKcalloc_L() description for details - same applies here."]
    pub fn FDKaalloc_L(
        size: UINT,
        alignment: UINT,
        s: MEMORY_SECTION,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Free memory that was allocated in a specific memory section."]
    pub fn FDKfree_L(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Free aligned memory that was allocated in a specific memory section."]
    pub fn FDKafree_L(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Copy memory. Source and destination memory must not overlap."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memcpy(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    pub fn FDKmemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: UINT,
    );
}
extern "C" {
    #[doc = " Copy memory. Source and destination memory are allowed to overlap."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memmove(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    pub fn FDKmemmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: UINT,
    );
}
extern "C" {
    #[doc = " Clear memory."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memclear(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    pub fn FDKmemclear(memPtr: *mut ::std::os::raw::c_void, size: UINT);
}
extern "C" {
    #[doc = " Fill memory with values."]
    #[doc = " The function arguments correspond to the standard memset(). Please see MSDN"]
    #[doc = " documentation for details on how to use it."]
    pub fn FDKmemset(memPtr: *mut ::std::os::raw::c_void, value: INT, size: UINT);
}
extern "C" {
    pub fn FDKmemcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        size: UINT,
    ) -> INT;
}
extern "C" {
    pub fn FDKstrcmp(s1: *const ::std::os::raw::c_char, s2: *const ::std::os::raw::c_char) -> INT;
}
extern "C" {
    pub fn FDKstrncmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        size: UINT,
    ) -> INT;
}
extern "C" {
    pub fn FDKstrlen(s: *const ::std::os::raw::c_char) -> UINT;
}
extern "C" {
    #[doc = "  Check platform for endianess."]
    #[doc = ""]
    #[doc = " \\return  1 if platform is little endian, non-1 if platform is big endian."]
    pub fn IS_LITTLE_ENDIAN() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Convert input value to little endian format."]
    #[doc = ""]
    #[doc = " \\param val  Value to be converted. It may be in both big or little endian."]
    #[doc = " \\return     Value in little endian format."]
    pub fn TO_LITTLE_ENDIAN(val: UINT) -> UINT;
}
#[doc = " \\fn     FDKFILE *FDKfopen(const char *filename, const char *mode);"]
#[doc = "         Standard fopen() wrapper."]
#[doc = " \\fn     INT FDKfclose(FDKFILE *FP);"]
#[doc = "         Standard fclose() wrapper."]
#[doc = " \\fn     INT FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);"]
#[doc = "         Standard fseek() wrapper."]
#[doc = " \\fn     INT FDKftell(FDKFILE *FP);"]
#[doc = "         Standard ftell() wrapper."]
#[doc = " \\fn     INT FDKfflush(FDKFILE *fp);"]
#[doc = "         Standard fflush() wrapper."]
#[doc = " \\fn     UINT FDKfwrite(const void *ptrf, INT size, UINT nmemb, FDKFILE *fp);"]
#[doc = "         Standard fwrite() wrapper."]
#[doc = " \\fn     UINT FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);"]
#[doc = "         Standard fread() wrapper."]
pub type FDKFILE = ::std::os::raw::c_void;
extern "C" {
    pub static FDKSEEK_SET: INT;
}
extern "C" {
    pub static FDKSEEK_CUR: INT;
}
extern "C" {
    pub static FDKSEEK_END: INT;
}
extern "C" {
    pub fn FDKfopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FDKFILE;
}
extern "C" {
    pub fn FDKfclose(FP: *mut FDKFILE) -> INT;
}
extern "C" {
    pub fn FDKfseek(FP: *mut FDKFILE, OFFSET: INT, WHENCE: ::std::os::raw::c_int) -> INT;
}
extern "C" {
    pub fn FDKftell(FP: *mut FDKFILE) -> INT;
}
extern "C" {
    pub fn FDKfflush(fp: *mut FDKFILE) -> INT;
}
extern "C" {
    pub fn FDKfwrite(
        ptrf: *const ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    pub fn FDKfread(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    pub fn FDKfgets(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        fp: *mut FDKFILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FDKrewind(fp: *mut FDKFILE);
}
extern "C" {
    pub fn FDKfeof(fp: *mut FDKFILE) -> INT;
}
extern "C" {
    #[doc = " \\brief        Write each member in little endian order. Convert automatically"]
    #[doc = " to host endianess."]
    #[doc = " \\param ptrf   Pointer to memory where to read data from."]
    #[doc = " \\param size   Size of each item to be written."]
    #[doc = " \\param nmemb  Number of items to be written."]
    #[doc = " \\param fp     File pointer of type FDKFILE."]
    #[doc = " \\return       Number of items read on success and fread() error on failure."]
    pub fn FDKfwrite_EL(
        ptrf: *const ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[doc = " \\brief        Read variable of size \"size\" as little endian. Convert"]
    #[doc = " automatically to host endianess. 4-byte alignment is enforced for 24 bit"]
    #[doc = " data, at 32 bit full scale."]
    #[doc = " \\param dst    Pointer to memory where to store data into."]
    #[doc = " \\param size   Size of each item to be read."]
    #[doc = " \\param nmemb  Number of items to be read."]
    #[doc = " \\param fp     File pointer of type FDKFILE."]
    #[doc = " \\return       Number of items read on success and fread() error on failure."]
    pub fn FDKfread_EL(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[doc = " \\brief  Print FDK software disclaimer."]
    pub fn FDKprintDisclaimer();
}
#[doc = " \\brief  Contains information needed for a single channel map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CHANNEL_MAP_INFO {
    #[doc = "< Actual channel mapping for one single configuration."]
    pub pChannelMap: *const UCHAR,
    #[doc = "< The number of channels for the channel map which is"]
    #[doc = "the maximum used channel index+1."]
    pub numChannels: UCHAR,
}
#[test]
fn bindgen_test_layout_CHANNEL_MAP_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CHANNEL_MAP_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(CHANNEL_MAP_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CHANNEL_MAP_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(CHANNEL_MAP_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CHANNEL_MAP_INFO>())).pChannelMap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHANNEL_MAP_INFO),
            "::",
            stringify!(pChannelMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CHANNEL_MAP_INFO>())).numChannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CHANNEL_MAP_INFO),
            "::",
            stringify!(numChannels)
        )
    );
}
#[doc = " \\brief   This is the main data struct. It contains the mapping for all"]
#[doc = " channel configurations such as administration information."]
#[doc = ""]
#[doc = " CAUTION: Do not access this structure directly from a algorithm specific"]
#[doc = " library. Always use one of the API access functions below!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FDK_channelMapDescr {
    #[doc = "< Table of channel maps."]
    pub pMapInfoTab: *const CHANNEL_MAP_INFO,
    #[doc = "< Length of the channel map table array."]
    pub mapInfoTabLen: UINT,
    #[doc = "< Flag that defines whether the specified mapping shall"]
    #[doc = "be applied  (value: 0) or the input just gets passed"]
    #[doc = "through (MPEG mapping)."]
    pub fPassThrough: UINT,
}
#[test]
fn bindgen_test_layout_FDK_channelMapDescr() {
    assert_eq!(
        ::std::mem::size_of::<FDK_channelMapDescr>(),
        16usize,
        concat!("Size of: ", stringify!(FDK_channelMapDescr))
    );
    assert_eq!(
        ::std::mem::align_of::<FDK_channelMapDescr>(),
        8usize,
        concat!("Alignment of ", stringify!(FDK_channelMapDescr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_channelMapDescr>())).pMapInfoTab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(pMapInfoTab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDK_channelMapDescr>())).mapInfoTabLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(mapInfoTabLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDK_channelMapDescr>())).fPassThrough as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(fPassThrough)
        )
    );
}
extern "C" {
    #[doc = " \\brief  Initialize a given channel map descriptor."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr      Pointer to a channel map descriptor to be initialized."]
    #[doc = " \\param  pMapInfoTab    Table of channel maps to initizalize the descriptor"]
    #[doc = "with."]
    #[doc = "                        If a NULL pointer is given a default table for"]
    #[doc = "WAV-like mapping will be used."]
    #[doc = " \\param  mapInfoTabLen  Length of the channel map table array (pMapInfoTab)."]
    #[doc = "If a zero length is given a default table for WAV-like mapping will be used."]
    #[doc = " \\param  fPassThrough   If the flag is set the reordering (given by"]
    #[doc = "pMapInfoTab) will be bypassed."]
    pub fn FDK_chMapDescr_init(
        pMapDescr: *mut FDK_channelMapDescr,
        pMapInfoTab: *const CHANNEL_MAP_INFO,
        mapInfoTabLen: UINT,
        fPassThrough: UINT,
    );
}
extern "C" {
    #[doc = " \\brief  Change the channel reordering state of a given channel map"]
    #[doc = " descriptor."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr     Pointer to a (initialized) channel map descriptor."]
    #[doc = " \\param  fPassThrough  If the flag is set the reordering (given by"]
    #[doc = " pMapInfoTab) will be bypassed."]
    #[doc = " \\return               Value unequal to zero if set operation was not"]
    #[doc = " successful. And zero on success."]
    pub fn FDK_chMapDescr_setPassThrough(
        pMapDescr: *mut FDK_channelMapDescr,
        fPassThrough: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief  Get the mapping value for a specific channel and map index."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr  Pointer to channel map descriptor."]
    #[doc = " \\param  chIdx      Channel index."]
    #[doc = " \\param  mapIdx     Mapping index (corresponding to the channel configuration"]
    #[doc = " index)."]
    #[doc = " \\return            Mapping value."]
    pub fn FDK_chMapDescr_getMapValue(
        pMapDescr: *const FDK_channelMapDescr,
        chIdx: UCHAR,
        mapIdx: UINT,
    ) -> UCHAR;
}
extern "C" {
    #[doc = " \\brief  Evaluate whether channel map descriptor is reasonable or not."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr Pointer to channel map descriptor."]
    #[doc = " \\return           Value unequal to zero if descriptor is valid, otherwise"]
    #[doc = " zero."]
    pub fn FDK_chMapDescr_isValid(pMapDescr: *const FDK_channelMapDescr) -> ::std::os::raw::c_int;
}
#[doc = "< Unknown format."]
pub const FILE_FORMAT_FF_UNKNOWN: FILE_FORMAT = -1;
#[doc = "< No container, bit stream data conveyed \"as is\"."]
pub const FILE_FORMAT_FF_RAW: FILE_FORMAT = 0;
#[doc = "< 3GPP file format."]
pub const FILE_FORMAT_FF_MP4_3GPP: FILE_FORMAT = 3;
#[doc = "< MPEG-4 File format."]
pub const FILE_FORMAT_FF_MP4_MP4F: FILE_FORMAT = 4;
#[doc = "< Proprietary raw packet file."]
pub const FILE_FORMAT_FF_RAWPACKETS: FILE_FORMAT = 5;
#[doc = " File format identifiers."]
pub type FILE_FORMAT = i32;
#[doc = "< Unknown format."]
pub const TRANSPORT_TYPE_TT_UNKNOWN: TRANSPORT_TYPE = -1;
#[doc = "< \"as is\" access units (packet based since there is"]
#[doc = "obviously no sync layer)"]
pub const TRANSPORT_TYPE_TT_MP4_RAW: TRANSPORT_TYPE = 0;
#[doc = "< ADIF bitstream format."]
pub const TRANSPORT_TYPE_TT_MP4_ADIF: TRANSPORT_TYPE = 1;
#[doc = "< ADTS bitstream format."]
pub const TRANSPORT_TYPE_TT_MP4_ADTS: TRANSPORT_TYPE = 2;
#[doc = "< Audio Mux Elements with muxConfigPresent = 1"]
pub const TRANSPORT_TYPE_TT_MP4_LATM_MCP1: TRANSPORT_TYPE = 6;
#[doc = "< Audio Mux Elements with muxConfigPresent = 0, out"]
#[doc = "of band StreamMuxConfig"]
pub const TRANSPORT_TYPE_TT_MP4_LATM_MCP0: TRANSPORT_TYPE = 7;
#[doc = "< Audio Sync Stream."]
pub const TRANSPORT_TYPE_TT_MP4_LOAS: TRANSPORT_TYPE = 10;
#[doc = "< Digital Radio Mondial (DRM30/DRM+) bitstream format."]
pub const TRANSPORT_TYPE_TT_DRM: TRANSPORT_TYPE = 12;
#[doc = " Transport type identifiers."]
pub type TRANSPORT_TYPE = i32;
pub const AUDIO_OBJECT_TYPE_AOT_NONE: AUDIO_OBJECT_TYPE = -1;
pub const AUDIO_OBJECT_TYPE_AOT_NULL_OBJECT: AUDIO_OBJECT_TYPE = 0;
#[doc = "< Main profile"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_MAIN: AUDIO_OBJECT_TYPE = 1;
#[doc = "< Low Complexity object"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_LC: AUDIO_OBJECT_TYPE = 2;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SSR: AUDIO_OBJECT_TYPE = 3;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_LTP: AUDIO_OBJECT_TYPE = 4;
pub const AUDIO_OBJECT_TYPE_AOT_SBR: AUDIO_OBJECT_TYPE = 5;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SCAL: AUDIO_OBJECT_TYPE = 6;
pub const AUDIO_OBJECT_TYPE_AOT_TWIN_VQ: AUDIO_OBJECT_TYPE = 7;
pub const AUDIO_OBJECT_TYPE_AOT_CELP: AUDIO_OBJECT_TYPE = 8;
pub const AUDIO_OBJECT_TYPE_AOT_HVXC: AUDIO_OBJECT_TYPE = 9;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_10: AUDIO_OBJECT_TYPE = 10;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_11: AUDIO_OBJECT_TYPE = 11;
#[doc = "< TTSI Object"]
pub const AUDIO_OBJECT_TYPE_AOT_TTSI: AUDIO_OBJECT_TYPE = 12;
#[doc = "< Main Synthetic object"]
pub const AUDIO_OBJECT_TYPE_AOT_MAIN_SYNTH: AUDIO_OBJECT_TYPE = 13;
#[doc = "< Wavetable Synthesis object"]
pub const AUDIO_OBJECT_TYPE_AOT_WAV_TAB_SYNTH: AUDIO_OBJECT_TYPE = 14;
#[doc = "< General MIDI object"]
pub const AUDIO_OBJECT_TYPE_AOT_GEN_MIDI: AUDIO_OBJECT_TYPE = 15;
#[doc = "< Algorithmic Synthesis and Audio FX object"]
pub const AUDIO_OBJECT_TYPE_AOT_ALG_SYNTH_AUD_FX: AUDIO_OBJECT_TYPE = 16;
#[doc = "< Error Resilient(ER) AAC Low Complexity"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LC: AUDIO_OBJECT_TYPE = 17;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_18: AUDIO_OBJECT_TYPE = 18;
#[doc = "< Error Resilient(ER) AAC LTP object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LTP: AUDIO_OBJECT_TYPE = 19;
#[doc = "< Error Resilient(ER) AAC Scalable object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_SCAL: AUDIO_OBJECT_TYPE = 20;
#[doc = "< Error Resilient(ER) TwinVQ object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_TWIN_VQ: AUDIO_OBJECT_TYPE = 21;
#[doc = "< Error Resilient(ER) BSAC object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_BSAC: AUDIO_OBJECT_TYPE = 22;
#[doc = "< Error Resilient(ER) AAC LowDelay object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LD: AUDIO_OBJECT_TYPE = 23;
#[doc = "< Error Resilient(ER) CELP object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_CELP: AUDIO_OBJECT_TYPE = 24;
#[doc = "< Error Resilient(ER) HVXC object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_HVXC: AUDIO_OBJECT_TYPE = 25;
#[doc = "< Error Resilient(ER) HILN object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_HILN: AUDIO_OBJECT_TYPE = 26;
#[doc = "< Error Resilient(ER) Parametric object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_PARA: AUDIO_OBJECT_TYPE = 27;
#[doc = "< might become SSC"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_28: AUDIO_OBJECT_TYPE = 28;
#[doc = "< PS, Parametric Stereo (includes SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_PS: AUDIO_OBJECT_TYPE = 29;
#[doc = "< MPEG Surround"]
pub const AUDIO_OBJECT_TYPE_AOT_MPEGS: AUDIO_OBJECT_TYPE = 30;
#[doc = "< Signal AOT uses more than 5 bits"]
pub const AUDIO_OBJECT_TYPE_AOT_ESCAPE: AUDIO_OBJECT_TYPE = 31;
#[doc = "< MPEG-Layer1 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L1: AUDIO_OBJECT_TYPE = 32;
#[doc = "< MPEG-Layer2 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L2: AUDIO_OBJECT_TYPE = 33;
#[doc = "< MPEG-Layer3 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L3: AUDIO_OBJECT_TYPE = 34;
#[doc = "< might become DST"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_35: AUDIO_OBJECT_TYPE = 35;
#[doc = "< might become ALS"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_36: AUDIO_OBJECT_TYPE = 36;
#[doc = "< AAC + SLS"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SLS: AUDIO_OBJECT_TYPE = 37;
#[doc = "< SLS"]
pub const AUDIO_OBJECT_TYPE_AOT_SLS: AUDIO_OBJECT_TYPE = 38;
#[doc = "< AAC Enhanced Low Delay"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_ELD: AUDIO_OBJECT_TYPE = 39;
#[doc = "< USAC"]
pub const AUDIO_OBJECT_TYPE_AOT_USAC: AUDIO_OBJECT_TYPE = 42;
#[doc = "< SAOC"]
pub const AUDIO_OBJECT_TYPE_AOT_SAOC: AUDIO_OBJECT_TYPE = 43;
#[doc = "< Low Delay MPEG Surround"]
pub const AUDIO_OBJECT_TYPE_AOT_LD_MPEGS: AUDIO_OBJECT_TYPE = 44;
#[doc = "< Virtual AOT MP2 Low Complexity profile"]
pub const AUDIO_OBJECT_TYPE_AOT_MP2_AAC_LC: AUDIO_OBJECT_TYPE = 129;
#[doc = "< Virtual AOT MP2 Low Complexity Profile with SBR"]
pub const AUDIO_OBJECT_TYPE_AOT_MP2_SBR: AUDIO_OBJECT_TYPE = 132;
#[doc = "< Virtual AOT for DRM (ER-AAC-SCAL without SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_AAC: AUDIO_OBJECT_TYPE = 143;
#[doc = "< Virtual AOT for DRM (ER-AAC-SCAL with SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_SBR: AUDIO_OBJECT_TYPE = 144;
pub const AUDIO_OBJECT_TYPE_AOT_DRM_MPEG_PS: AUDIO_OBJECT_TYPE = 145;
pub const AUDIO_OBJECT_TYPE_AOT_DRM_SURROUND: AUDIO_OBJECT_TYPE = 146;
#[doc = "< Virtual AOT for DRM with USAC"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_USAC: AUDIO_OBJECT_TYPE = 147;
#[doc = " Audio Object Type definitions."]
pub type AUDIO_OBJECT_TYPE = i32;
pub const CHANNEL_MODE_MODE_INVALID: CHANNEL_MODE = -1;
pub const CHANNEL_MODE_MODE_UNKNOWN: CHANNEL_MODE = 0;
#[doc = "< C"]
pub const CHANNEL_MODE_MODE_1: CHANNEL_MODE = 1;
#[doc = "< L+R"]
pub const CHANNEL_MODE_MODE_2: CHANNEL_MODE = 2;
#[doc = "< C, L+R"]
pub const CHANNEL_MODE_MODE_1_2: CHANNEL_MODE = 3;
#[doc = "< C, L+R, Rear"]
pub const CHANNEL_MODE_MODE_1_2_1: CHANNEL_MODE = 4;
#[doc = "< C, L+R, LS+RS"]
pub const CHANNEL_MODE_MODE_1_2_2: CHANNEL_MODE = 5;
#[doc = "< C, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_1_2_2_1: CHANNEL_MODE = 6;
#[doc = "< C, LC+RC, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_1_2_2_2_1: CHANNEL_MODE = 7;
#[doc = "< C, L+R, LS+RS, Crear, LFE"]
pub const CHANNEL_MODE_MODE_6_1: CHANNEL_MODE = 11;
#[doc = "< C, L+R, LS+RS, Lrear+Rrear, LFE"]
pub const CHANNEL_MODE_MODE_7_1_BACK: CHANNEL_MODE = 12;
#[doc = "< C, L+R, LS+RS, LFE, Ltop+Rtop"]
pub const CHANNEL_MODE_MODE_7_1_TOP_FRONT: CHANNEL_MODE = 14;
#[doc = "< C, L+R, LS+RS, Lrear+Rrear, LFE"]
pub const CHANNEL_MODE_MODE_7_1_REAR_SURROUND: CHANNEL_MODE = 33;
#[doc = "< C, LC+RC, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_7_1_FRONT_CENTER: CHANNEL_MODE = 34;
#[doc = "< 212 configuration, used in ELDv2"]
pub const CHANNEL_MODE_MODE_212: CHANNEL_MODE = 128;
#[doc = " Channel Mode ( 1-7 equals MPEG channel configurations, others are"]
#[doc = " arbitrary)."]
pub type CHANNEL_MODE = i32;
pub const AUDIO_CHANNEL_TYPE_ACT_NONE: AUDIO_CHANNEL_TYPE = 0;
#[doc = "< Front speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT: AUDIO_CHANNEL_TYPE = 1;
#[doc = "< Side speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE: AUDIO_CHANNEL_TYPE = 2;
#[doc = "< Back speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK: AUDIO_CHANNEL_TYPE = 3;
#[doc = "< Low frequency effect speaker postion (front)"]
pub const AUDIO_CHANNEL_TYPE_ACT_LFE: AUDIO_CHANNEL_TYPE = 4;
pub const AUDIO_CHANNEL_TYPE_ACT_TOP: AUDIO_CHANNEL_TYPE = 16;
#[doc = "< Top front speaker = (ACT_FRONT|ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT_TOP: AUDIO_CHANNEL_TYPE = 17;
#[doc = "< Top side speaker  = (ACT_SIDE |ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE_TOP: AUDIO_CHANNEL_TYPE = 18;
#[doc = "< Top back speaker  = (ACT_BACK |ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK_TOP: AUDIO_CHANNEL_TYPE = 19;
pub const AUDIO_CHANNEL_TYPE_ACT_BOTTOM: AUDIO_CHANNEL_TYPE = 32;
#[doc = "< Bottom front speaker = (ACT_FRONT|ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT_BOTTOM: AUDIO_CHANNEL_TYPE = 33;
#[doc = "< Bottom side speaker  = (ACT_SIDE |ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE_BOTTOM: AUDIO_CHANNEL_TYPE = 34;
#[doc = "< Bottom back speaker  = (ACT_BACK |ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK_BOTTOM: AUDIO_CHANNEL_TYPE = 35;
#[doc = " Speaker description tags."]
#[doc = " Do not change the enumeration values unless it keeps the following"]
#[doc = " segmentation:"]
#[doc = " - Bit 0-3: Horizontal postion (0: none, 1: front, 2: side, 3: back, 4: lfe)"]
#[doc = " - Bit 4-7: Vertical position (0: normal, 1: top, 2: bottom)"]
pub type AUDIO_CHANNEL_TYPE = u32;
pub const SBR_PS_SIGNALING_SIG_UNKNOWN: SBR_PS_SIGNALING = -1;
pub const SBR_PS_SIGNALING_SIG_IMPLICIT: SBR_PS_SIGNALING = 0;
pub const SBR_PS_SIGNALING_SIG_EXPLICIT_BW_COMPATIBLE: SBR_PS_SIGNALING = 1;
pub const SBR_PS_SIGNALING_SIG_EXPLICIT_HIERARCHICAL: SBR_PS_SIGNALING = 2;
pub type SBR_PS_SIGNALING = i32;
#[doc = " Generic audio coder configuration structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CODER_CONFIG {
    #[doc = "< Audio Object Type (AOT)."]
    pub aot: AUDIO_OBJECT_TYPE,
    #[doc = "< Extension Audio Object Type (SBR)."]
    pub extAOT: AUDIO_OBJECT_TYPE,
    #[doc = "< Channel mode."]
    pub channelMode: CHANNEL_MODE,
    #[doc = "< Use channel config zero + pce although a"]
    #[doc = "standard channel config could be signaled."]
    pub channelConfigZero: UCHAR,
    #[doc = "< Sampling rate."]
    pub samplingRate: INT,
    #[doc = "< Extended samplerate (SBR)."]
    pub extSamplingRate: INT,
    #[doc = "< Downscale sampling rate (ELD downscaled mode)"]
    pub downscaleSamplingRate: INT,
    #[doc = "< Average bitrate."]
    pub bitRate: INT,
    #[doc = "< Number of PCM samples per codec frame and audio"]
    #[doc = "channel."]
    pub samplesPerFrame: ::std::os::raw::c_int,
    #[doc = "< Number of audio channels."]
    pub noChannels: ::std::os::raw::c_int,
    pub bitsFrame: ::std::os::raw::c_int,
    #[doc = "< Amount of encoder subframes. 1 means no subframing."]
    pub nSubFrames: ::std::os::raw::c_int,
    #[doc = "< The number of the sub-frames which are grouped and"]
    #[doc = "transmitted in a super-frame (BSAC)."]
    pub BSACnumOfSubFrame: ::std::os::raw::c_int,
    #[doc = "< The average length of the large-step layers in bytes"]
    #[doc = "(BSAC)."]
    pub BSAClayerLength: ::std::os::raw::c_int,
    #[doc = "< flags"]
    pub flags: UINT,
    #[doc = "< Matrix mixdown index to put into PCE. Default value"]
    #[doc = "0 means no mixdown coefficient, valid values are 1-4"]
    #[doc = "which correspond to matrix_mixdown_idx 0-3."]
    pub matrixMixdownA: UCHAR,
    #[doc = "< Frame period for sending in band configuration"]
    #[doc = "buffers in the transport layer."]
    pub headerPeriod: UCHAR,
    #[doc = "< USAC MPS stereo mode"]
    pub stereoConfigIndex: UCHAR,
    #[doc = "< USAC SBR mode"]
    pub sbrMode: UCHAR,
    #[doc = "< 0: implicit signaling, 1: backwards"]
    #[doc = "compatible explicit signaling, 2:"]
    #[doc = "hierarcical explicit signaling"]
    pub sbrSignaling: SBR_PS_SIGNALING,
    #[doc = "< raw codec specific config as bit stream"]
    pub rawConfig: [UCHAR; 64usize],
    #[doc = "< Size of rawConfig in bits"]
    pub rawConfigBits: ::std::os::raw::c_int,
    pub sbrPresent: UCHAR,
    pub psPresent: UCHAR,
}
#[test]
fn bindgen_test_layout_CODER_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<CODER_CONFIG>(),
        140usize,
        concat!("Size of: ", stringify!(CODER_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<CODER_CONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(CODER_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).aot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(aot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).extAOT as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(extAOT)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).channelMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(channelMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).channelConfigZero as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(channelConfigZero)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).samplingRate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(samplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).extSamplingRate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(extSamplingRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CODER_CONFIG>())).downscaleSamplingRate as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(downscaleSamplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).bitRate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(bitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).samplesPerFrame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(samplesPerFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).noChannels as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(noChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).bitsFrame as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(bitsFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).nSubFrames as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(nSubFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).BSACnumOfSubFrame as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(BSACnumOfSubFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).BSAClayerLength as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(BSAClayerLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).matrixMixdownA as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(matrixMixdownA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).headerPeriod as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(headerPeriod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).stereoConfigIndex as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(stereoConfigIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrMode as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrSignaling as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrSignaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).rawConfig as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(rawConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).rawConfigBits as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(rawConfigBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrPresent as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).psPresent as *const _ as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(psPresent)
        )
    );
}
#[doc = "< Invalid Element helper ID."]
pub const MP4_ELEMENT_ID_ID_NONE: MP4_ELEMENT_ID = -1;
#[doc = "< Single Channel Element."]
pub const MP4_ELEMENT_ID_ID_SCE: MP4_ELEMENT_ID = 0;
#[doc = "< Channel Pair Element."]
pub const MP4_ELEMENT_ID_ID_CPE: MP4_ELEMENT_ID = 1;
#[doc = "< Coupling Channel Element."]
pub const MP4_ELEMENT_ID_ID_CCE: MP4_ELEMENT_ID = 2;
#[doc = "< LFE Channel Element."]
pub const MP4_ELEMENT_ID_ID_LFE: MP4_ELEMENT_ID = 3;
#[doc = "< Currently one Data Stream Element for ancillary data is"]
#[doc = "supported."]
pub const MP4_ELEMENT_ID_ID_DSE: MP4_ELEMENT_ID = 4;
#[doc = "< Program Config Element."]
pub const MP4_ELEMENT_ID_ID_PCE: MP4_ELEMENT_ID = 5;
#[doc = "< Fill Element."]
pub const MP4_ELEMENT_ID_ID_FIL: MP4_ELEMENT_ID = 6;
#[doc = "< Arnie (End Element = Terminator)."]
pub const MP4_ELEMENT_ID_ID_END: MP4_ELEMENT_ID = 7;
#[doc = "< Extension Payload (ER only)."]
pub const MP4_ELEMENT_ID_ID_EXT: MP4_ELEMENT_ID = 8;
#[doc = "< AAC scalable element (ER only)."]
pub const MP4_ELEMENT_ID_ID_SCAL: MP4_ELEMENT_ID = 9;
#[doc = "< Single Channel Element."]
pub const MP4_ELEMENT_ID_ID_USAC_SCE: MP4_ELEMENT_ID = 16;
#[doc = "< Channel Pair Element."]
pub const MP4_ELEMENT_ID_ID_USAC_CPE: MP4_ELEMENT_ID = 17;
#[doc = "< LFE Channel Element."]
pub const MP4_ELEMENT_ID_ID_USAC_LFE: MP4_ELEMENT_ID = 18;
#[doc = "< Extension Element."]
pub const MP4_ELEMENT_ID_ID_USAC_EXT: MP4_ELEMENT_ID = 19;
#[doc = "< Arnie (End Element = Terminator)."]
pub const MP4_ELEMENT_ID_ID_USAC_END: MP4_ELEMENT_ID = 20;
pub const MP4_ELEMENT_ID_ID_LAST: MP4_ELEMENT_ID = 21;
#[doc = " MP4 Element IDs."]
pub type MP4_ELEMENT_ID = i32;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_FILL: CONFIG_EXT_ID = 0;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_DOWNMIX: CONFIG_EXT_ID = 1;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_LOUDNESS_INFO: CONFIG_EXT_ID = 2;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_AUDIOSCENE_INFO: CONFIG_EXT_ID = 3;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_HOA_MATRIX: CONFIG_EXT_ID = 4;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_SIG_GROUP_INFO: CONFIG_EXT_ID = 6;
pub type CONFIG_EXT_ID = u32;
pub const EXT_PAYLOAD_TYPE_EXT_FIL: EXT_PAYLOAD_TYPE = 0;
pub const EXT_PAYLOAD_TYPE_EXT_FILL_DATA: EXT_PAYLOAD_TYPE = 1;
pub const EXT_PAYLOAD_TYPE_EXT_DATA_ELEMENT: EXT_PAYLOAD_TYPE = 2;
pub const EXT_PAYLOAD_TYPE_EXT_DATA_LENGTH: EXT_PAYLOAD_TYPE = 3;
pub const EXT_PAYLOAD_TYPE_EXT_UNI_DRC: EXT_PAYLOAD_TYPE = 4;
pub const EXT_PAYLOAD_TYPE_EXT_LDSAC_DATA: EXT_PAYLOAD_TYPE = 9;
pub const EXT_PAYLOAD_TYPE_EXT_SAOC_DATA: EXT_PAYLOAD_TYPE = 10;
pub const EXT_PAYLOAD_TYPE_EXT_DYNAMIC_RANGE: EXT_PAYLOAD_TYPE = 11;
pub const EXT_PAYLOAD_TYPE_EXT_SAC_DATA: EXT_PAYLOAD_TYPE = 12;
pub const EXT_PAYLOAD_TYPE_EXT_SBR_DATA: EXT_PAYLOAD_TYPE = 13;
pub const EXT_PAYLOAD_TYPE_EXT_SBR_DATA_CRC: EXT_PAYLOAD_TYPE = 14;
#[doc = " Extension payload types."]
pub type EXT_PAYLOAD_TYPE = u32;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_FILL: USAC_EXT_ELEMENT_TYPE = 0;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_MPEGS: USAC_EXT_ELEMENT_TYPE = 1;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_SAOC: USAC_EXT_ELEMENT_TYPE = 2;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_AUDIOPREROLL: USAC_EXT_ELEMENT_TYPE = 3;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_UNI_DRC: USAC_EXT_ELEMENT_TYPE = 4;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_OBJ_METADATA: USAC_EXT_ELEMENT_TYPE = 5;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_SAOC_3D: USAC_EXT_ELEMENT_TYPE = 6;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_HOA: USAC_EXT_ELEMENT_TYPE = 7;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_FMT_CNVRTR: USAC_EXT_ELEMENT_TYPE = 8;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_MCT: USAC_EXT_ELEMENT_TYPE = 9;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_ENHANCED_OBJ_METADATA: USAC_EXT_ELEMENT_TYPE = 13;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_VR_METADATA: USAC_EXT_ELEMENT_TYPE = 129;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_UNKNOWN: USAC_EXT_ELEMENT_TYPE = 255;
#[doc = " MPEG-D USAC & RSVD60 3D audio Extension Element Types."]
pub type USAC_EXT_ELEMENT_TYPE = u32;
pub const TP_CONFIG_TYPE_TC_NOTHING: TP_CONFIG_TYPE = 0;
pub const TP_CONFIG_TYPE_TC_RAW_ADTS: TP_CONFIG_TYPE = 2;
pub const TP_CONFIG_TYPE_TC_RAW_LATM_MCP1: TP_CONFIG_TYPE = 6;
pub const TP_CONFIG_TYPE_TC_RAW_SDC: TP_CONFIG_TYPE = 21;
#[doc = " Proprietary raw packet file configuration data type identifier."]
pub type TP_CONFIG_TYPE = u32;
pub const FDK_MODULE_ID_FDK_NONE: FDK_MODULE_ID = 0;
pub const FDK_MODULE_ID_FDK_TOOLS: FDK_MODULE_ID = 1;
pub const FDK_MODULE_ID_FDK_SYSLIB: FDK_MODULE_ID = 2;
pub const FDK_MODULE_ID_FDK_AACDEC: FDK_MODULE_ID = 3;
pub const FDK_MODULE_ID_FDK_AACENC: FDK_MODULE_ID = 4;
pub const FDK_MODULE_ID_FDK_SBRDEC: FDK_MODULE_ID = 5;
pub const FDK_MODULE_ID_FDK_SBRENC: FDK_MODULE_ID = 6;
pub const FDK_MODULE_ID_FDK_TPDEC: FDK_MODULE_ID = 7;
pub const FDK_MODULE_ID_FDK_TPENC: FDK_MODULE_ID = 8;
pub const FDK_MODULE_ID_FDK_MPSDEC: FDK_MODULE_ID = 9;
pub const FDK_MODULE_ID_FDK_MPEGFILEREAD: FDK_MODULE_ID = 10;
pub const FDK_MODULE_ID_FDK_MPEGFILEWRITE: FDK_MODULE_ID = 11;
pub const FDK_MODULE_ID_FDK_PCMDMX: FDK_MODULE_ID = 31;
pub const FDK_MODULE_ID_FDK_MPSENC: FDK_MODULE_ID = 34;
pub const FDK_MODULE_ID_FDK_TDLIMIT: FDK_MODULE_ID = 35;
pub const FDK_MODULE_ID_FDK_UNIDRCDEC: FDK_MODULE_ID = 38;
pub const FDK_MODULE_ID_FDK_MODULE_LAST: FDK_MODULE_ID = 39;
pub type FDK_MODULE_ID = u32;
#[doc = "  Library information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIB_INFO {
    pub title: *const ::std::os::raw::c_char,
    pub build_date: *const ::std::os::raw::c_char,
    pub build_time: *const ::std::os::raw::c_char,
    pub module_id: FDK_MODULE_ID,
    pub version: INT,
    pub flags: UINT,
    pub versionStr: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_LIB_INFO() {
    assert_eq!(
        ::std::mem::size_of::<LIB_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(LIB_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<LIB_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(LIB_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).build_date as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(build_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).build_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(build_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).module_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).version as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).versionStr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(versionStr)
        )
    );
}
#[doc = "  I/O buffer descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FDK_bufDescr {
    #[doc = "< Pointer to an array containing buffer base addresses."]
    #[doc = "Set to NULL for buffer requirement info."]
    pub ppBase: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to an array containing the number of elements"]
    #[doc = "that can be placed in the specific buffer."]
    pub pBufSize: *mut UINT,
    #[doc = "< Pointer to an array containing the element size for each"]
    #[doc = "buffer in bytes. That is mostly the number returned by the"]
    #[doc = "sizeof() operator for the data type used for the specific"]
    #[doc = "buffer."]
    pub pEleSize: *mut UINT,
    #[doc = "< Pointer to an array of bit fields containing a description"]
    #[doc = "for each buffer. See XXX below for more details."]
    pub pBufType: *mut UINT,
    #[doc = "< Total number of buffers."]
    pub numBufs: UINT,
}
#[test]
fn bindgen_test_layout_FDK_bufDescr() {
    assert_eq!(
        ::std::mem::size_of::<FDK_bufDescr>(),
        40usize,
        concat!("Size of: ", stringify!(FDK_bufDescr))
    );
    assert_eq!(
        ::std::mem::align_of::<FDK_bufDescr>(),
        8usize,
        concat!("Alignment of ", stringify!(FDK_bufDescr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).ppBase as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(ppBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pBufSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pBufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pEleSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pEleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pBufType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pBufType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).numBufs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(numBufs)
        )
    );
}
#[doc = "< No error happened. All fine."]
pub const AACENC_ERROR_AACENC_OK: AACENC_ERROR = 0;
pub const AACENC_ERROR_AACENC_INVALID_HANDLE: AACENC_ERROR = 32;
#[doc = "< Memory allocation failed."]
pub const AACENC_ERROR_AACENC_MEMORY_ERROR: AACENC_ERROR = 33;
#[doc = "< Parameter not available."]
pub const AACENC_ERROR_AACENC_UNSUPPORTED_PARAMETER: AACENC_ERROR = 34;
#[doc = "< Configuration not provided."]
pub const AACENC_ERROR_AACENC_INVALID_CONFIG: AACENC_ERROR = 35;
#[doc = "< General initialization error."]
pub const AACENC_ERROR_AACENC_INIT_ERROR: AACENC_ERROR = 64;
#[doc = "< AAC library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_AAC_ERROR: AACENC_ERROR = 65;
#[doc = "< SBR library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_SBR_ERROR: AACENC_ERROR = 66;
#[doc = "< Transport library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_TP_ERROR: AACENC_ERROR = 67;
pub const AACENC_ERROR_AACENC_INIT_META_ERROR: AACENC_ERROR = 68;
#[doc = "< MPS library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_MPS_ERROR: AACENC_ERROR = 69;
#[doc = "< The encoding process was interrupted by an"]
#[doc = "unexpected error."]
pub const AACENC_ERROR_AACENC_ENCODE_ERROR: AACENC_ERROR = 96;
#[doc = "< End of file reached."]
pub const AACENC_ERROR_AACENC_ENCODE_EOF: AACENC_ERROR = 128;
#[doc = "  AAC encoder error codes."]
pub type AACENC_ERROR = u32;
#[doc = "< Audio input buffer, interleaved INT_PCM samples."]
pub const AACENC_BufferIdentifier_IN_AUDIO_DATA: AACENC_BufferIdentifier = 0;
#[doc = "< Ancillary data to be embedded into bitstream."]
pub const AACENC_BufferIdentifier_IN_ANCILLRY_DATA: AACENC_BufferIdentifier = 1;
#[doc = "< Setup structure for embedding meta data."]
pub const AACENC_BufferIdentifier_IN_METADATA_SETUP: AACENC_BufferIdentifier = 2;
#[doc = "< Buffer holds bitstream output data."]
pub const AACENC_BufferIdentifier_OUT_BITSTREAM_DATA: AACENC_BufferIdentifier = 3;
pub const AACENC_BufferIdentifier_OUT_AU_SIZES: AACENC_BufferIdentifier = 4;
#[doc = "  AAC encoder buffer descriptors identifier."]
#[doc = "  This identifier are used within buffer descriptors"]
#[doc = " AACENC_BufDesc::bufferIdentifiers."]
pub type AACENC_BufferIdentifier = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENCODER {
    _unused: [u8; 0],
}
#[doc = "  AAC encoder handle."]
pub type HANDLE_AACENCODER = *mut AACENCODER;
#[doc = "  Provides some info about the encoder configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AACENC_InfoStruct {
    #[doc = "< Maximum number of encoder bitstream bytes within one"]
    #[doc = "frame. Size depends on maximum number of supported"]
    #[doc = "channels in encoder instance. For superframing (as"]
    #[doc = "used for example in DAB+), size has to be a multiple"]
    #[doc = "accordingly."]
    pub maxOutBufBytes: UINT,
    #[doc = "< Maximum number of ancillary data bytes which can be"]
    #[doc = "inserted into bitstream within one frame."]
    pub maxAncBytes: UINT,
    #[doc = "< Internal input buffer fill level in samples per"]
    #[doc = "channel. This parameter will automatically be cleared"]
    #[doc = "if samplingrate or channel(Mode/Order) changes."]
    pub inBufFillLevel: UINT,
    #[doc = "< Number of input channels expected in encoding"]
    #[doc = "process."]
    pub inputChannels: UINT,
    #[doc = "< Amount of input audio samples consumed each frame per"]
    #[doc = "channel, depending on audio object type configuration."]
    pub frameLength: UINT,
    #[doc = "< Codec delay in PCM samples/channel. Depends on framelength"]
    #[doc = "and AOT. Does not include framing delay for filling up encoder"]
    #[doc = "PCM input buffer."]
    pub nDelay: UINT,
    #[doc = "< Codec delay in PCM samples/channel, w/o delay caused by"]
    #[doc = "the decoder SBR module. This delay is needed to correctly"]
    #[doc = "write edit lists for gapless playback. The decoder may not"]
    #[doc = "know how much delay is introdcued by SBR, since it may not"]
    #[doc = "know if SBR is active at all (implicit signaling),"]
    #[doc = "therefore the deocder must take into account any delay"]
    #[doc = "caused by the SBR module."]
    pub nDelayCore: UINT,
    #[doc = "< Configuration buffer in binary format as an"]
    #[doc = "AudioSpecificConfig or StreamMuxConfig according to the"]
    #[doc = "selected transport type."]
    pub confBuf: [UCHAR; 64usize],
    #[doc = "< Number of valid bytes in confBuf."]
    pub confSize: UINT,
}
#[test]
fn bindgen_test_layout_AACENC_InfoStruct() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_InfoStruct>(),
        96usize,
        concat!("Size of: ", stringify!(AACENC_InfoStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_InfoStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_InfoStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_InfoStruct>())).maxOutBufBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(maxOutBufBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).maxAncBytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(maxAncBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_InfoStruct>())).inBufFillLevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(inBufFillLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).inputChannels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(inputChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).frameLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(frameLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).nDelay as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(nDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).nDelayCore as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(nDelayCore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).confBuf as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(confBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).confSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(confSize)
        )
    );
}
#[doc = "  Describes the input and output buffers for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_BufDesc {
    #[doc = "< Number of buffers."]
    pub numBufs: INT,
    #[doc = "< Pointer to vector containing buffer addresses."]
    pub bufs: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Identifier of each buffer element. See"]
    #[doc = "::AACENC_BufferIdentifier."]
    pub bufferIdentifiers: *mut INT,
    #[doc = "< Size of each buffer in 8-bit bytes."]
    pub bufSizes: *mut INT,
    #[doc = "< Size of each buffer element in bytes."]
    pub bufElSizes: *mut INT,
}
#[test]
fn bindgen_test_layout_AACENC_BufDesc() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_BufDesc>(),
        40usize,
        concat!("Size of: ", stringify!(AACENC_BufDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_BufDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(AACENC_BufDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).numBufs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(numBufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_BufDesc>())).bufferIdentifiers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufferIdentifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufSizes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufElSizes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufElSizes)
        )
    );
}
#[doc = "  Defines the input arguments for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_InArgs {
    #[doc = "< Number of valid input audio samples (multiple of input"]
    #[doc = "channels)."]
    pub numInSamples: INT,
    #[doc = "< Number of ancillary data bytes to be encoded."]
    pub numAncBytes: INT,
}
#[test]
fn bindgen_test_layout_AACENC_InArgs() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_InArgs>(),
        8usize,
        concat!("Size of: ", stringify!(AACENC_InArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_InArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_InArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InArgs>())).numInSamples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InArgs),
            "::",
            stringify!(numInSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InArgs>())).numAncBytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InArgs),
            "::",
            stringify!(numAncBytes)
        )
    );
}
#[doc = "  Defines the output arguments for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_OutArgs {
    #[doc = "< Number of valid bitstream bytes generated during"]
    #[doc = "aacEncEncode()."]
    pub numOutBytes: INT,
    #[doc = "< Number of input audio samples consumed by the encoder."]
    pub numInSamples: INT,
    #[doc = "< Number of ancillary data bytes consumed by the encoder."]
    pub numAncBytes: INT,
    #[doc = "< State of the bit reservoir in bits."]
    pub bitResState: INT,
}
#[test]
fn bindgen_test_layout_AACENC_OutArgs() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_OutArgs>(),
        16usize,
        concat!("Size of: ", stringify!(AACENC_OutArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_OutArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_OutArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numOutBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numOutBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numInSamples as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numInSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numAncBytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numAncBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).bitResState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(bitResState)
        )
    );
}
#[doc = "< None."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_NONE: AACENC_METADATA_DRC_PROFILE = 0;
#[doc = "< Film standard."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_FILMSTANDARD:
    AACENC_METADATA_DRC_PROFILE = 1;
#[doc = "< Film light."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_FILMLIGHT: AACENC_METADATA_DRC_PROFILE =
    2;
#[doc = "< Music standard."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_MUSICSTANDARD:
    AACENC_METADATA_DRC_PROFILE = 3;
#[doc = "< Music light."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_MUSICLIGHT: AACENC_METADATA_DRC_PROFILE =
    4;
#[doc = "< Speech."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_SPEECH: AACENC_METADATA_DRC_PROFILE = 5;
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_NOT_PRESENT: AACENC_METADATA_DRC_PROFILE =
    256;
#[doc = "  Meta Data Compression Profiles."]
pub type AACENC_METADATA_DRC_PROFILE = u32;
#[doc = "  Meta Data setup structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_MetaData {
    #[doc = "< MPEG DRC compression profile. See"]
    #[doc = "::AACENC_METADATA_DRC_PROFILE."]
    pub drc_profile: AACENC_METADATA_DRC_PROFILE,
    #[doc = "< ETSI heavy compression profile. See"]
    #[doc = "::AACENC_METADATA_DRC_PROFILE."]
    pub comp_profile: AACENC_METADATA_DRC_PROFILE,
    #[doc = "< Used to define expected level to:"]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub drc_TargetRefLevel: INT,
    #[doc = "< Adjust limiter to avoid overload."]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub comp_TargetRefLevel: INT,
    #[doc = "< Flag, if prog_ref_level is present"]
    pub prog_ref_level_present: INT,
    #[doc = "< Programme Reference Level = Dialogue Level:"]
    #[doc = "-31.75dB .. 0 dB ; stepsize: 0.25dB"]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub prog_ref_level: INT,
    #[doc = "< Flag, if dmx-idx should be written in"]
    #[doc = "programme config element"]
    pub PCE_mixdown_idx_present: UCHAR,
    #[doc = "< Flag, if dmx-lvl should be written in"]
    #[doc = "ETSI-ancData"]
    pub ETSI_DmxLvl_present: UCHAR,
    #[doc = "< Center downmix level (0...7, according to table)"]
    pub centerMixLevel: SCHAR,
    #[doc = "< Surround downmix level (0...7, according to"]
    #[doc = "table)"]
    pub surroundMixLevel: SCHAR,
    #[doc = "< Indication for Dolby Surround Encoding Mode."]
    #[doc = "- 0: Dolby Surround mode not indicated"]
    #[doc = "- 1: 2-ch audio part is not Dolby surround encoded"]
    #[doc = "- 2: 2-ch audio part is Dolby surround encoded"]
    pub dolbySurroundMode: UCHAR,
    #[doc = "< Indicatin for DRC Presentation Mode."]
    #[doc = "- 0: Presentation mode not inticated"]
    #[doc = "- 1: Presentation mode 1"]
    #[doc = "- 2: Presentation mode 2"]
    pub drcPresentationMode: UCHAR,
    pub ExtMetaData: AACENC_MetaData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_MetaData__bindgen_ty_1 {
    pub extAncDataEnable: UCHAR,
    pub extDownmixLevelEnable: UCHAR,
    pub extDownmixLevel_A: UCHAR,
    pub extDownmixLevel_B: UCHAR,
    pub dmxGainEnable: UCHAR,
    pub dmxGain5: INT,
    pub dmxGain2: INT,
    pub lfeDmxEnable: UCHAR,
    pub lfeDmxLevel: UCHAR,
}
#[test]
fn bindgen_test_layout_AACENC_MetaData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_MetaData__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(AACENC_MetaData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_MetaData__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_MetaData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extAncDataEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extAncDataEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevelEnable
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevelEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevel_A as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevel_A)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevel_B as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevel_B)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGainEnable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGainEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGain5 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGain5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGain2 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGain2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).lfeDmxEnable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(lfeDmxEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).lfeDmxLevel as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(lfeDmxLevel)
        )
    );
}
#[test]
fn bindgen_test_layout_AACENC_MetaData() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_MetaData>(),
        52usize,
        concat!("Size of: ", stringify!(AACENC_MetaData))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_MetaData>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_MetaData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).drc_profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drc_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).comp_profile as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(comp_profile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).drc_TargetRefLevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drc_TargetRefLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).comp_TargetRefLevel as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(comp_TargetRefLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).prog_ref_level_present as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(prog_ref_level_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).prog_ref_level as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(prog_ref_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).PCE_mixdown_idx_present as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(PCE_mixdown_idx_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).ETSI_DmxLvl_present as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(ETSI_DmxLvl_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).centerMixLevel as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(centerMixLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).surroundMixLevel as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(surroundMixLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).dolbySurroundMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(dolbySurroundMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).drcPresentationMode as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drcPresentationMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).ExtMetaData as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(ExtMetaData)
        )
    );
}
#[doc = "< Do not trigger initialization."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_NONE: AACENC_CTRLFLAGS = 0;
pub const AACENC_CTRLFLAGS_AACENC_INIT_CONFIG: AACENC_CTRLFLAGS = 1;
#[doc = "< Reset all encoder modules history buffer."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_STATES: AACENC_CTRLFLAGS = 2;
pub const AACENC_CTRLFLAGS_AACENC_INIT_TRANSPORT: AACENC_CTRLFLAGS = 4096;
pub const AACENC_CTRLFLAGS_AACENC_RESET_INBUFFER: AACENC_CTRLFLAGS = 8192;
#[doc = "< Initialize all."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_ALL: AACENC_CTRLFLAGS = 65535;
#[doc = " AAC encoder control flags."]
#[doc = ""]
#[doc = " In interaction with the ::AACENC_CONTROL_STATE parameter it is possible to"]
#[doc = " get information about the internal initialization process. It is also"]
#[doc = " possible to overwrite the internal state from extern when necessary."]
pub type AACENC_CTRLFLAGS = u32;
pub const AACENC_PARAM_AACENC_AOT: AACENC_PARAM = 256;
#[doc = "< Total encoder bitrate. This parameter is"]
#[doc = "mandatory and interacts with ::AACENC_BITRATEMODE."]
#[doc = "- CBR: Bitrate in bits/second."]
#[doc = "- VBR: Variable bitrate. Bitrate argument will"]
#[doc = "be ignored. See \\ref suppBitrates for details."]
pub const AACENC_PARAM_AACENC_BITRATE: AACENC_PARAM = 257;
#[doc = "< Bitrate mode. Configuration can be different"]
#[doc = "kind of bitrate configurations:"]
#[doc = "- 0: Constant bitrate, use bitrate according"]
#[doc = "to ::AACENC_BITRATE. (default) Within none"]
#[doc = "LD/ELD ::AUDIO_OBJECT_TYPE, the CBR mode makes"]
#[doc = "use of full allowed bitreservoir. In contrast,"]
#[doc = "at Low-Delay ::AUDIO_OBJECT_TYPE the"]
#[doc = "bitreservoir is kept very small."]
#[doc = "- 1: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"very low bitrate\"."]
#[doc = "- 2: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"low bitrate\"."]
#[doc = "- 3: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"medium bitrate\"."]
#[doc = "- 4: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"high bitrate\"."]
#[doc = "- 5: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"very high bitrate\"."]
pub const AACENC_PARAM_AACENC_BITRATEMODE: AACENC_PARAM = 258;
#[doc = "< Audio input data sampling rate. Encoder"]
#[doc = "supports following sampling rates: 8000, 11025,"]
#[doc = "12000, 16000, 22050, 24000, 32000, 44100,"]
#[doc = "48000, 64000, 88200, 96000"]
pub const AACENC_PARAM_AACENC_SAMPLERATE: AACENC_PARAM = 259;
#[doc = "< Configure SBR independently of the chosen Audio"]
#[doc = "Object Type ::AUDIO_OBJECT_TYPE. This parameter"]
#[doc = "is for ELD audio object type only."]
#[doc = "- -1: Use ELD SBR auto configurator (default)."]
#[doc = "- 0: Disable Spectral Band Replication."]
#[doc = "- 1: Enable Spectral Band Replication."]
pub const AACENC_PARAM_AACENC_SBR_MODE: AACENC_PARAM = 260;
pub const AACENC_PARAM_AACENC_GRANULE_LENGTH: AACENC_PARAM = 261;
#[doc = "< Set explicit channel mode. Channel mode must"]
#[doc = "match with number of input channels."]
#[doc = "- 1-7, 11,12,14 and 33,34: MPEG channel"]
#[doc = "modes supported, see ::CHANNEL_MODE in"]
#[doc = "FDK_audio.h."]
pub const AACENC_PARAM_AACENC_CHANNELMODE: AACENC_PARAM = 262;
pub const AACENC_PARAM_AACENC_CHANNELORDER: AACENC_PARAM = 263;
pub const AACENC_PARAM_AACENC_SBR_RATIO: AACENC_PARAM = 264;
pub const AACENC_PARAM_AACENC_AFTERBURNER: AACENC_PARAM = 512;
#[doc = "< Core encoder audio bandwidth:"]
#[doc = "- 0: Determine audio bandwidth internally"]
#[doc = "(default, see chapter \\ref BEHAVIOUR_BANDWIDTH)."]
#[doc = "- 1 to fs/2: Audio bandwidth in Hertz. Limited"]
#[doc = "to 20kHz max. Not usable if SBR is active. This"]
#[doc = "setting is for experts only, better do not touch"]
#[doc = "this value to avoid degraded audio quality."]
pub const AACENC_PARAM_AACENC_BANDWIDTH: AACENC_PARAM = 515;
pub const AACENC_PARAM_AACENC_PEAK_BITRATE: AACENC_PARAM = 519;
#[doc = "< Transport type to be used. See ::TRANSPORT_TYPE"]
#[doc = "in FDK_audio.h. Following types can be configured"]
#[doc = "in encoder library:"]
#[doc = "- 0: raw access units"]
#[doc = "- 1: ADIF bitstream format"]
#[doc = "- 2: ADTS bitstream format"]
#[doc = "- 6: Audio Mux Elements (LATM) with"]
#[doc = "muxConfigPresent = 1"]
#[doc = "- 7: Audio Mux Elements (LATM) with"]
#[doc = "muxConfigPresent = 0, out of band StreamMuxConfig"]
#[doc = "- 10: Audio Sync Stream (LOAS)"]
pub const AACENC_PARAM_AACENC_TRANSMUX: AACENC_PARAM = 768;
pub const AACENC_PARAM_AACENC_HEADER_PERIOD: AACENC_PARAM = 769;
pub const AACENC_PARAM_AACENC_SIGNALING_MODE: AACENC_PARAM = 770;
pub const AACENC_PARAM_AACENC_TPSUBFRAMES: AACENC_PARAM = 771;
pub const AACENC_PARAM_AACENC_AUDIOMUXVER: AACENC_PARAM = 772;
#[doc = "< Configure protection in transport layer:"]
#[doc = "- 0: No protection. (default)"]
#[doc = "- 1: CRC active for ADTS transport format."]
pub const AACENC_PARAM_AACENC_PROTECTION: AACENC_PARAM = 774;
pub const AACENC_PARAM_AACENC_ANCILLARY_BITRATE: AACENC_PARAM = 1280;
#[doc = "< Configure Meta Data. See ::AACENC_MetaData"]
#[doc = "for further details:"]
#[doc = "- 0: Do not embed any metadata."]
#[doc = "- 1: Embed dynamic_range_info metadata."]
#[doc = "- 2: Embed dynamic_range_info and"]
#[doc = "ancillary_data metadata."]
#[doc = "- 3: Embed ancillary_data metadata."]
pub const AACENC_PARAM_AACENC_METADATA_MODE: AACENC_PARAM = 1536;
pub const AACENC_PARAM_AACENC_CONTROL_STATE: AACENC_PARAM = 65280;
#[doc = "< ------"]
pub const AACENC_PARAM_AACENC_NONE: AACENC_PARAM = 65535;
#[doc = " \\brief  AAC encoder setting parameters."]
#[doc = ""]
#[doc = " Use aacEncoder_SetParam() function to configure, or use aacEncoder_GetParam()"]
#[doc = " function to read the internal status of the following parameters."]
pub type AACENC_PARAM = u32;
extern "C" {
    #[doc = " \\brief  Open an instance of the encoder."]
    #[doc = ""]
    #[doc = " Allocate memory for an encoder instance with a functional range denoted by"]
    #[doc = " the function parameters. Preinitialize encoder instance with default"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " \\param phAacEncoder  A pointer to an encoder handle. Initialized on return."]
    #[doc = " \\param encModules    Specify encoder modules to be supported in this encoder"]
    #[doc = " instance:"]
    #[doc = "                      - 0x0: Allocate memory for all available encoder"]
    #[doc = " modules."]
    #[doc = "                      - else: Select memory allocation regarding encoder"]
    #[doc = " modules. Following flags are possible and can be combined."]
    #[doc = "                              - 0x01: AAC module."]
    #[doc = "                              - 0x02: SBR module."]
    #[doc = "                              - 0x04: PS module."]
    #[doc = "                              - 0x08: MPS module."]
    #[doc = "                              - 0x10: Metadata module."]
    #[doc = "                              - example: (0x01|0x02|0x04|0x08|0x10) allocates"]
    #[doc = " all modules and is equivalent to default configuration denotet by 0x0."]
    #[doc = " \\param maxChannels   Number of channels to be allocated. This parameter can"]
    #[doc = " be used in different ways:"]
    #[doc = "                      - 0: Allocate maximum number of AAC and SBR channels as"]
    #[doc = " supported by the library."]
    #[doc = "                      - nChannels: Use same maximum number of channels for"]
    #[doc = " allocating memory in AAC and SBR module."]
    #[doc = "                      - nChannels | (nSbrCh<<8): Number of SBR channels can be"]
    #[doc = " different to AAC channels to save data memory."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on succes."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_MEMORY_ERROR, AACENC_INVALID_CONFIG,"]
    #[doc = " on failure."]
    pub fn aacEncOpen(
        phAacEncoder: *mut HANDLE_AACENCODER,
        encModules: UINT,
        maxChannels: UINT,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Close the encoder instance."]
    #[doc = ""]
    #[doc = " Deallocate encoder instance and free whole memory."]
    #[doc = ""]
    #[doc = " \\param phAacEncoder  Pointer to the encoder handle to be deallocated."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, on failure."]
    pub fn aacEncClose(phAacEncoder: *mut HANDLE_AACENCODER) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief Encode audio data."]
    #[doc = ""]
    #[doc = " This function is mainly for encoding audio data. In addition the function can"]
    #[doc = " be used for an encoder (re)configuration process."]
    #[doc = " - PCM input data will be retrieved from external input buffer until the fill"]
    #[doc = " level allows encoding a single frame. This functionality allows an external"]
    #[doc = " buffer with reduced size in comparison to the AAC or HE-AAC audio frame"]
    #[doc = " length."]
    #[doc = " - If the value of the input samples argument is zero, just internal"]
    #[doc = " reinitialization will be applied if it is requested."]
    #[doc = " - At the end of a file the flushing process can be triggerd via setting the"]
    #[doc = " value of the input samples argument to -1. The encoder delay lines are fully"]
    #[doc = " flushed when the encoder returns no valid bitstream data"]
    #[doc = " AACENC_OutArgs::numOutBytes. Furthermore the end of file is signaled by the"]
    #[doc = " return value AACENC_ENCODE_EOF."]
    #[doc = " - If an error occured in the previous frame or any of the encoder parameters"]
    #[doc = " changed, an internal reinitialization process will be applied before encoding"]
    #[doc = " the incoming audio samples."]
    #[doc = " - The function can also be used for an independent reconfiguration process"]
    #[doc = " without encoding. The first parameter has to be a valid encoder handle and"]
    #[doc = " all other parameters can be set to NULL."]
    #[doc = " - If the size of the external bitbuffer in outBufDesc is not sufficient for"]
    #[doc = " writing the whole bitstream, an internal error will be the return value and a"]
    #[doc = " reconfiguration will be triggered."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param inBufDesc             Input buffer descriptor, see AACENC_BufDesc:"]
    #[doc = "                              - At least one input buffer with audio data is"]
    #[doc = " expected."]
    #[doc = "                              - Optionally a second input buffer with"]
    #[doc = " ancillary data can be fed."]
    #[doc = " \\param outBufDesc            Output buffer descriptor, see AACENC_BufDesc:"]
    #[doc = "                              - Provide one output buffer for the encoded"]
    #[doc = " bitstream."]
    #[doc = " \\param inargs                Input arguments, see AACENC_InArgs."]
    #[doc = " \\param outargs               Output arguments, AACENC_OutArgs."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_ENCODE_ERROR, on failure in encoding"]
    #[doc = " process."]
    #[doc = "          - AACENC_INVALID_CONFIG, AACENC_INIT_ERROR, AACENC_INIT_AAC_ERROR,"]
    #[doc = " AACENC_INIT_SBR_ERROR, AACENC_INIT_TP_ERROR, AACENC_INIT_META_ERROR,"]
    #[doc = " AACENC_INIT_MPS_ERROR, on failure in encoder initialization."]
    #[doc = "          - AACENC_UNSUPPORTED_PARAMETER, on incorrect input or output buffer"]
    #[doc = " descriptor initialization."]
    #[doc = "          - AACENC_ENCODE_EOF, when flushing fully concluded."]
    pub fn aacEncEncode(
        hAacEncoder: HANDLE_AACENCODER,
        inBufDesc: *const AACENC_BufDesc,
        outBufDesc: *const AACENC_BufDesc,
        inargs: *const AACENC_InArgs,
        outargs: *mut AACENC_OutArgs,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Acquire info about present encoder instance."]
    #[doc = ""]
    #[doc = " This function retrieves information of the encoder configuration. In addition"]
    #[doc = " to informative internal states, a configuration data block of the current"]
    #[doc = " encoder settings will be returned. The format is either Audio Specific Config"]
    #[doc = " in case of Raw Packets transport format or StreamMuxConfig in case of"]
    #[doc = " LOAS/LATM transport format. The configuration data block is binary coded as"]
    #[doc = " specified in ISO/IEC 14496-3 (MPEG-4 audio), to be used directly for MPEG-4"]
    #[doc = " File Format or RFC3016 or RFC3640 applications."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param pInfo                 Pointer to AACENC_InfoStruct. Filled on return."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on succes."]
    #[doc = "          - AACENC_INIT_ERROR, on failure."]
    pub fn aacEncInfo(
        hAacEncoder: HANDLE_AACENCODER,
        pInfo: *mut AACENC_InfoStruct,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Set one single AAC encoder parameter."]
    #[doc = ""]
    #[doc = " This function allows configuration of all encoder parameters specified in"]
    #[doc = " ::AACENC_PARAM. Each parameter must be set with a separate function call. An"]
    #[doc = " internal validation of the configuration value range will be done and an"]
    #[doc = " internal reconfiguration will be signaled. The actual configuration adoption"]
    #[doc = " is part of the subsequent aacEncEncode() call."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param param                 Parameter to be set. See ::AACENC_PARAM."]
    #[doc = " \\param value                 Parameter value. See parameter description in"]
    #[doc = " ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_UNSUPPORTED_PARAMETER,"]
    #[doc = " AACENC_INVALID_CONFIG, on failure."]
    pub fn aacEncoder_SetParam(
        hAacEncoder: HANDLE_AACENCODER,
        param: AACENC_PARAM,
        value: UINT,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Get one single AAC encoder parameter."]
    #[doc = ""]
    #[doc = " This function is the complement to aacEncoder_SetParam(). After encoder"]
    #[doc = " reinitialization with user defined settings, the internal status can be"]
    #[doc = " obtained of each parameter, specified with ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param param                 Parameter to be returned. See ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\return  Internal configuration value of specifed parameter ::AACENC_PARAM."]
    pub fn aacEncoder_GetParam(hAacEncoder: HANDLE_AACENCODER, param: AACENC_PARAM) -> UINT;
}
extern "C" {
    #[doc = " \\brief  Get information about encoder library build."]
    #[doc = ""]
    #[doc = " Fill a given LIB_INFO structure with library version information."]
    #[doc = ""]
    #[doc = " \\param info  Pointer to an allocated LIB_INFO struct."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_INIT_ERROR, on failure."]
    pub fn aacEncGetLibInfo(info: *mut LIB_INFO) -> AACENC_ERROR;
}
pub const AAC_DECODER_ERROR_AAC_DEC_OK: AAC_DECODER_ERROR = 0;
pub const AAC_DECODER_ERROR_AAC_DEC_OUT_OF_MEMORY: AAC_DECODER_ERROR = 2;
pub const AAC_DECODER_ERROR_AAC_DEC_UNKNOWN: AAC_DECODER_ERROR = 5;
pub const AAC_DECODER_ERROR_aac_dec_sync_error_start: AAC_DECODER_ERROR = 4096;
#[doc = "< The transport decoder had"]
#[doc = "synchronization problems. Do not"]
#[doc = "exit decoding. Just feed new"]
#[doc = "bitstream data."]
pub const AAC_DECODER_ERROR_AAC_DEC_TRANSPORT_SYNC_ERROR: AAC_DECODER_ERROR = 4097;
#[doc = "< The input buffer ran out of bits."]
pub const AAC_DECODER_ERROR_AAC_DEC_NOT_ENOUGH_BITS: AAC_DECODER_ERROR = 4098;
pub const AAC_DECODER_ERROR_aac_dec_sync_error_end: AAC_DECODER_ERROR = 8191;
pub const AAC_DECODER_ERROR_aac_dec_init_error_start: AAC_DECODER_ERROR = 8192;
pub const AAC_DECODER_ERROR_AAC_DEC_INVALID_HANDLE: AAC_DECODER_ERROR = 8193;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_AOT: AAC_DECODER_ERROR = 8194;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_FORMAT: AAC_DECODER_ERROR = 8195;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_ER_FORMAT: AAC_DECODER_ERROR = 8196;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_EPCONFIG: AAC_DECODER_ERROR = 8197;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_MULTILAYER: AAC_DECODER_ERROR = 8198;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_CHANNELCONFIG: AAC_DECODER_ERROR = 8199;
#[doc = "< The sample rate specified in"]
#[doc = "the configuration is not"]
#[doc = "supported."]
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_SAMPLINGRATE: AAC_DECODER_ERROR = 8200;
pub const AAC_DECODER_ERROR_AAC_DEC_INVALID_SBR_CONFIG: AAC_DECODER_ERROR = 8201;
#[doc = "< The parameter could not be set. Either"]
#[doc = "the value was out of range or the"]
#[doc = "parameter does  not exist."]
pub const AAC_DECODER_ERROR_AAC_DEC_SET_PARAM_FAIL: AAC_DECODER_ERROR = 8202;
#[doc = "< The decoder needs to be restarted,"]
#[doc = "since the required configuration change"]
#[doc = "cannot be performed."]
pub const AAC_DECODER_ERROR_AAC_DEC_NEED_TO_RESTART: AAC_DECODER_ERROR = 8203;
pub const AAC_DECODER_ERROR_AAC_DEC_OUTPUT_BUFFER_TOO_SMALL: AAC_DECODER_ERROR = 8204;
pub const AAC_DECODER_ERROR_aac_dec_init_error_end: AAC_DECODER_ERROR = 12287;
pub const AAC_DECODER_ERROR_aac_dec_decode_error_start: AAC_DECODER_ERROR = 16384;
pub const AAC_DECODER_ERROR_AAC_DEC_TRANSPORT_ERROR: AAC_DECODER_ERROR = 16385;
#[doc = "< Error while parsing the bitstream. Most"]
#[doc = "probably it is corrupted, or the system"]
#[doc = "crashed."]
pub const AAC_DECODER_ERROR_AAC_DEC_PARSE_ERROR: AAC_DECODER_ERROR = 16386;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_EXTENSION_PAYLOAD: AAC_DECODER_ERROR = 16387;
#[doc = "< The parsed bitstream value is out of"]
#[doc = "range. Most probably the bitstream is"]
#[doc = "corrupt, or the system crashed."]
pub const AAC_DECODER_ERROR_AAC_DEC_DECODE_FRAME_ERROR: AAC_DECODER_ERROR = 16388;
#[doc = "< The embedded CRC did not match."]
pub const AAC_DECODER_ERROR_AAC_DEC_CRC_ERROR: AAC_DECODER_ERROR = 16389;
#[doc = "< An invalid codebook was signaled."]
#[doc = "Most probably the bitstream is corrupt,"]
#[doc = "or the system  crashed."]
pub const AAC_DECODER_ERROR_AAC_DEC_INVALID_CODE_BOOK: AAC_DECODER_ERROR = 16390;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_PREDICTION: AAC_DECODER_ERROR = 16391;
#[doc = "< A CCE element was found which is not"]
#[doc = "supported. Most probably the bitstream is"]
#[doc = "corrupt, or has a wrong format."]
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_CCE: AAC_DECODER_ERROR = 16392;
#[doc = "< A LFE element was found which is not"]
#[doc = "supported. Most probably the bitstream is"]
#[doc = "corrupt, or has a wrong format."]
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_LFE: AAC_DECODER_ERROR = 16393;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_GAIN_CONTROL_DATA: AAC_DECODER_ERROR = 16394;
pub const AAC_DECODER_ERROR_AAC_DEC_UNSUPPORTED_SBA: AAC_DECODER_ERROR = 16395;
#[doc = "< Error while reading TNS data. Most"]
#[doc = "probably the bitstream is corrupt or the"]
#[doc = "system crashed."]
pub const AAC_DECODER_ERROR_AAC_DEC_TNS_READ_ERROR: AAC_DECODER_ERROR = 16396;
pub const AAC_DECODER_ERROR_AAC_DEC_RVLC_ERROR: AAC_DECODER_ERROR = 16397;
pub const AAC_DECODER_ERROR_aac_dec_decode_error_end: AAC_DECODER_ERROR = 20479;
pub const AAC_DECODER_ERROR_aac_dec_anc_data_error_start: AAC_DECODER_ERROR = 32768;
pub const AAC_DECODER_ERROR_AAC_DEC_ANC_DATA_ERROR: AAC_DECODER_ERROR = 32769;
#[doc = "< The registered ancillary data"]
#[doc = "buffer is too small to receive the"]
#[doc = "parsed data."]
pub const AAC_DECODER_ERROR_AAC_DEC_TOO_SMALL_ANC_BUFFER: AAC_DECODER_ERROR = 32770;
#[doc = "< More than the allowed number of"]
#[doc = "ancillary data elements should be"]
#[doc = "written to buffer."]
pub const AAC_DECODER_ERROR_AAC_DEC_TOO_MANY_ANC_ELEMENTS: AAC_DECODER_ERROR = 32771;
pub const AAC_DECODER_ERROR_aac_dec_anc_data_error_end: AAC_DECODER_ERROR = 36863;
#[doc = " \\brief  AAC decoder error codes."]
pub type AAC_DECODER_ERROR = u32;
pub const AAC_MD_PROFILE_AAC_MD_PROFILE_MPEG_STANDARD: AAC_MD_PROFILE = 0;
pub const AAC_MD_PROFILE_AAC_MD_PROFILE_MPEG_LEGACY: AAC_MD_PROFILE = 1;
pub const AAC_MD_PROFILE_AAC_MD_PROFILE_MPEG_LEGACY_PRIO: AAC_MD_PROFILE = 2;
pub const AAC_MD_PROFILE_AAC_MD_PROFILE_ARIB_JAPAN: AAC_MD_PROFILE = 3;
#[doc = " \\enum  AAC_MD_PROFILE"]
#[doc = "  \\brief The available metadata profiles which are mostly related to downmixing. The values define the arguments"]
#[doc = "         for the use with parameter ::AAC_METADATA_PROFILE."]
pub type AAC_MD_PROFILE = u32;
#[doc = "< DRC parameter handling"]
#[doc = "disabled, all parameters are"]
#[doc = "applied as requested."]
pub const AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS_AAC_DRC_PARAMETER_HANDLING_DISABLED:
    AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS = -1;
pub const AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS_AAC_DRC_PARAMETER_HANDLING_ENABLED:
    AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS = 0;
pub const AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS_AAC_DRC_PRESENTATION_MODE_1_DEFAULT:
    AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS = 1;
pub const AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS_AAC_DRC_PRESENTATION_MODE_2_DEFAULT:
    AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS = 2;
#[doc = " \\enum  AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS"]
#[doc = "  \\brief Options for handling of DRC parameters, if presentation mode is not indicated in bitstream"]
pub type AAC_DRC_DEFAULT_PRESENTATION_MODE_OPTIONS = i32;
pub const AACDEC_PARAM_AAC_PCM_DUAL_CHANNEL_OUTPUT_MODE: AACDEC_PARAM = 2;
pub const AACDEC_PARAM_AAC_PCM_OUTPUT_CHANNEL_MAPPING: AACDEC_PARAM = 3;
pub const AACDEC_PARAM_AAC_PCM_LIMITER_ENABLE: AACDEC_PARAM = 4;
#[doc = "< Signal level limiting attack time"]
#[doc = "in ms. Default configuration is 15"]
#[doc = "ms. Adjustable range from 1 ms to 15"]
#[doc = "ms."]
pub const AACDEC_PARAM_AAC_PCM_LIMITER_ATTACK_TIME: AACDEC_PARAM = 5;
#[doc = "< Signal level limiting release time"]
#[doc = "in ms. Default configuration is 50"]
#[doc = "ms. Adjustable time must be larger"]
#[doc = "than 0 ms."]
pub const AACDEC_PARAM_AAC_PCM_LIMITER_RELEAS_TIME: AACDEC_PARAM = 6;
pub const AACDEC_PARAM_AAC_PCM_MIN_OUTPUT_CHANNELS: AACDEC_PARAM = 17;
pub const AACDEC_PARAM_AAC_PCM_MAX_OUTPUT_CHANNELS: AACDEC_PARAM = 18;
pub const AACDEC_PARAM_AAC_METADATA_PROFILE: AACDEC_PARAM = 32;
#[doc = "< Defines the time in ms after which all"]
#[doc = "the bitstream associated meta-data (DRC,"]
#[doc = "downmix coefficients, ...) will be reset"]
#[doc = "to default if no update has been"]
#[doc = "received. Negative values disable the"]
#[doc = "feature."]
pub const AACDEC_PARAM_AAC_METADATA_EXPIRY_TIME: AACDEC_PARAM = 33;
#[doc = "< Error concealment: Processing method. \\n"]
#[doc = "0: Spectral muting. \\n"]
#[doc = "1: Noise substitution (see ::CONCEAL_NOISE)."]
#[doc = "\\n 2: Energy interpolation (adds additional"]
#[doc = "signal delay of one frame, see"]
#[doc = "::CONCEAL_INTER. only some AOTs are"]
#[doc = "supported). \\n"]
pub const AACDEC_PARAM_AAC_CONCEAL_METHOD: AACDEC_PARAM = 256;
pub const AACDEC_PARAM_AAC_DRC_BOOST_FACTOR: AACDEC_PARAM = 512;
#[doc = "< MPEG-4 / MPEG-D DRC: Scaling factor"]
#[doc = "for attenuating gain values. Same as"]
#[doc = "::AAC_DRC_BOOST_FACTOR but for"]
#[doc = "attenuating DRC factors."]
pub const AACDEC_PARAM_AAC_DRC_ATTENUATION_FACTOR: AACDEC_PARAM = 513;
pub const AACDEC_PARAM_AAC_DRC_REFERENCE_LEVEL: AACDEC_PARAM = 514;
pub const AACDEC_PARAM_AAC_DRC_HEAVY_COMPRESSION: AACDEC_PARAM = 515;
pub const AACDEC_PARAM_AAC_DRC_DEFAULT_PRESENTATION_MODE: AACDEC_PARAM = 516;
pub const AACDEC_PARAM_AAC_DRC_ENC_TARGET_LEVEL: AACDEC_PARAM = 517;
#[doc = "< MPEG-D DRC: Request a DRC effect type for"]
#[doc = "selection of a DRC set.\\n Supported indices"]
#[doc = "are:\\n -1: DRC off. Completely disables"]
#[doc = "MPEG-D DRC.\\n 0: None (default). Disables"]
#[doc = "MPEG-D DRC, but automatically enables DRC"]
#[doc = "if necessary to prevent clipping.\\n 1: Late"]
#[doc = "night\\n 2: Noisy environment\\n 3: Limited"]
#[doc = "playback range\\n 4: Low playback level\\n 5:"]
#[doc = "Dialog enhancement\\n 6: General"]
#[doc = "compression. Used for generally enabling"]
#[doc = "MPEG-D DRC without particular request.\\n"]
pub const AACDEC_PARAM_AAC_UNIDRC_SET_EFFECT: AACDEC_PARAM = 518;
pub const AACDEC_PARAM_AAC_UNIDRC_ALBUM_MODE: AACDEC_PARAM = 519;
#[doc = "< Quadrature Mirror Filter (QMF) Bank processing"]
#[doc = "mode. \\n -1: Use internal default. Implies MPEG"]
#[doc = "Surround partially complex accordingly. \\n 0:"]
#[doc = "Use complex QMF data mode. \\n 1: Use real (low"]
#[doc = "power) QMF data mode. \\n"]
pub const AACDEC_PARAM_AAC_QMF_LOWPOWER: AACDEC_PARAM = 768;
pub const AACDEC_PARAM_AAC_TPDEC_CLEAR_BUFFER: AACDEC_PARAM = 1539;
#[doc = " \\brief AAC decoder setting parameters"]
pub type AACDEC_PARAM = u32;
#[doc = " \\brief This structure gives information about the currently decoded audio"]
#[doc = " data. All fields are read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CStreamInfo {
    #[doc = "< The sample rate in Hz of the decoded PCM audio signal."]
    pub sampleRate: INT,
    #[doc = "< The frame size of the decoded PCM audio signal. \\n"]
    #[doc = "Typically this is: \\n"]
    #[doc = "1024 or 960 for AAC-LC \\n"]
    #[doc = "2048 or 1920 for HE-AAC (v2) \\n"]
    #[doc = "512 or 480 for AAC-LD and AAC-ELD \\n"]
    #[doc = "768, 1024, 2048 or 4096 for USAC"]
    pub frameSize: INT,
    #[doc = "< The number of output audio channels before the rendering"]
    #[doc = "module, i.e. the original channel configuration."]
    pub numChannels: INT,
    #[doc = "< Audio channel type of each output audio channel."]
    pub pChannelType: *mut AUDIO_CHANNEL_TYPE,
    #[doc = "< Audio channel index for each output audio"]
    #[doc = "channel. See ISO/IEC 13818-7:2005(E), 8.5.3.2"]
    #[doc = "Explicit channel mapping using a"]
    #[doc = "program_config_element()"]
    pub pChannelIndices: *mut UCHAR,
    #[doc = "< Sampling rate in Hz without SBR (from configuration"]
    #[doc = "info) divided by a (ELD) downscale factor if present."]
    pub aacSampleRate: INT,
    #[doc = "< MPEG-2 profile (from file header) (-1: not applicable (e. g."]
    #[doc = "MPEG-4))."]
    pub profile: INT,
    #[doc = "< Audio Object Type (from ASC): is set to the appropriate value"]
    #[doc = "for MPEG-2 bitstreams (e. g. 2 for AAC-LC)."]
    pub aot: AUDIO_OBJECT_TYPE,
    #[doc = "< Channel configuration (0: PCE defined, 1: mono, 2:"]
    #[doc = "stereo, ..."]
    pub channelConfig: INT,
    #[doc = "< Instantaneous bit rate."]
    pub bitRate: INT,
    #[doc = "< Samples per frame for the AAC core (from ASC)"]
    #[doc = "divided by a (ELD) downscale factor if present. \\n"]
    #[doc = "Typically this is (with a downscale factor of 1):"]
    #[doc = "\\n   1024 or 960 for AAC-LC \\n   512 or 480 for"]
    #[doc = "AAC-LD   and AAC-ELD"]
    pub aacSamplesPerFrame: INT,
    #[doc = "< The number of audio channels after AAC core"]
    #[doc = "processing (before PS or MPS processing).       CAUTION: This"]
    #[doc = "are not the final number of output channels!"]
    pub aacNumChannels: INT,
    #[doc = "< Extension Audio Object Type (from ASC)"]
    pub extAot: AUDIO_OBJECT_TYPE,
    #[doc = "< Extension sampling rate in Hz (from ASC) divided by"]
    #[doc = "a (ELD) downscale factor if present."]
    pub extSamplingRate: INT,
    #[doc = "< The number of samples the output is additionally"]
    #[doc = "delayed by.the decoder."]
    pub outputDelay: UINT,
    #[doc = "< Copy of internal flags. Only to be written by the decoder,"]
    #[doc = "and only to be read externally."]
    pub flags: UINT,
    #[doc = "< epConfig level (from ASC): only level 0 supported, -1"]
    #[doc = "means no ER (e. g. AOT=2, MPEG-2 AAC, etc.)"]
    pub epConfig: SCHAR,
    #[doc = "< This integer will reflect the estimated amount of"]
    #[doc = "lost access units in case aacDecoder_DecodeFrame()"]
    #[doc = "returns AAC_DEC_TRANSPORT_SYNC_ERROR. It will be"]
    #[doc = "< 0 if the estimation failed."]
    pub numLostAccessUnits: INT,
    #[doc = "< This is the number of total bytes that have passed"]
    #[doc = "through the decoder."]
    pub numTotalBytes: INT64,
    #[doc = "< This is the number of total bytes that were considered"]
    #[doc = "with errors from numTotalBytes."]
    pub numBadBytes: INT64,
    #[doc = "< This is the number of total access units that"]
    #[doc = "have passed through the decoder."]
    pub numTotalAccessUnits: INT64,
    #[doc = "< This is the number of total access units that"]
    #[doc = "were considered with errors from numTotalBytes."]
    pub numBadAccessUnits: INT64,
    #[doc = "< DRC program reference level. Defines the reference"]
    #[doc = "level below full-scale. It is quantized in steps of"]
    #[doc = "0.25dB. The valid values range from 0 (0 dBFS) to 127"]
    #[doc = "(-31.75 dBFS). It is used to reflect the average"]
    #[doc = "loudness of the audio in LKFS according to ITU-R BS"]
    #[doc = "1770. If no level has been found in the bitstream the"]
    #[doc = "value is -1."]
    pub drcProgRefLev: SCHAR,
    #[doc = "< DRC presentation mode. According to ETSI TS 101 154,"]
    #[doc = "this field indicates whether   light (MPEG-4 Dynamic Range"]
    #[doc = "Control tool) or heavy compression (DVB heavy"]
    #[doc = "compression)   dynamic range control shall take priority"]
    #[doc = "on the outputs.   For details, see ETSI TS 101 154, table"]
    #[doc = "C.33. Possible values are: \\n   -1: No corresponding"]
    #[doc = "metadata found in the bitstream \\n   0: DRC presentation"]
    #[doc = "mode not indicated \\n   1: DRC presentation mode 1 \\n   2:"]
    #[doc = "DRC presentation mode 2 \\n   3: Reserved"]
    pub drcPresMode: SCHAR,
}
#[test]
fn bindgen_test_layout_CStreamInfo() {
    assert_eq!(
        ::std::mem::size_of::<CStreamInfo>(),
        128usize,
        concat!("Size of: ", stringify!(CStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CStreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CStreamInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).sampleRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).frameSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(frameSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numChannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).pChannelType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(pChannelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).pChannelIndices as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(pChannelIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).aacSampleRate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(aacSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).profile as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).aot as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(aot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).channelConfig as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(channelConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).bitRate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(bitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).aacSamplesPerFrame as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(aacSamplesPerFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).aacNumChannels as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(aacNumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).extAot as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(extAot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).extSamplingRate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(extSamplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).outputDelay as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(outputDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).epConfig as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(epConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numLostAccessUnits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numLostAccessUnits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numTotalBytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numTotalBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numBadBytes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numBadBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numTotalAccessUnits as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numTotalAccessUnits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).numBadAccessUnits as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(numBadAccessUnits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).drcProgRefLev as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(drcProgRefLev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CStreamInfo>())).drcPresMode as *const _ as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(CStreamInfo),
            "::",
            stringify!(drcPresMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAC_DECODER_INSTANCE {
    _unused: [u8; 0],
}
pub type HANDLE_AACDECODER = *mut AAC_DECODER_INSTANCE;
extern "C" {
    #[doc = " \\brief Initialize ancillary data buffer."]
    #[doc = ""]
    #[doc = " \\param self    AAC decoder handle."]
    #[doc = " \\param buffer  Pointer to (external) ancillary data buffer."]
    #[doc = " \\param size    Size of the buffer pointed to by buffer."]
    #[doc = " \\return        Error code."]
    pub fn aacDecoder_AncDataInit(
        self_: HANDLE_AACDECODER,
        buffer: *mut UCHAR,
        size: ::std::os::raw::c_int,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief Get one ancillary data element."]
    #[doc = ""]
    #[doc = " \\param self   AAC decoder handle."]
    #[doc = " \\param index  Index of the ancillary data element to get."]
    #[doc = " \\param ptr    Pointer to a buffer receiving a pointer to the requested"]
    #[doc = " ancillary data element."]
    #[doc = " \\param size   Pointer to a buffer receiving the length of the requested"]
    #[doc = " ancillary data element."]
    #[doc = " \\return       Error code."]
    pub fn aacDecoder_AncDataGet(
        self_: HANDLE_AACDECODER,
        index: ::std::os::raw::c_int,
        ptr: *mut *mut UCHAR,
        size: *mut ::std::os::raw::c_int,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief Set one single decoder parameter."]
    #[doc = ""]
    #[doc = " \\param self   AAC decoder handle."]
    #[doc = " \\param param  Parameter to be set."]
    #[doc = " \\param value  Parameter value."]
    #[doc = " \\return       Error code."]
    pub fn aacDecoder_SetParam(
        self_: HANDLE_AACDECODER,
        param: AACDEC_PARAM,
        value: INT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief              Get free bytes inside decoder internal buffer."]
    #[doc = " \\param self         Handle of AAC decoder instance."]
    #[doc = " \\param pFreeBytes   Pointer to variable receiving amount of free bytes inside"]
    #[doc = " decoder internal buffer."]
    #[doc = " \\return             Error code."]
    pub fn aacDecoder_GetFreeBytes(
        self_: HANDLE_AACDECODER,
        pFreeBytes: *mut UINT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief               Open an AAC decoder instance."]
    #[doc = " \\param transportFmt  The transport type to be used."]
    #[doc = " \\param nrOfLayers    Number of transport layers."]
    #[doc = " \\return              AAC decoder handle."]
    pub fn aacDecoder_Open(transportFmt: TRANSPORT_TYPE, nrOfLayers: UINT) -> HANDLE_AACDECODER;
}
extern "C" {
    #[doc = " \\brief Explicitly configure the decoder by passing a raw AudioSpecificConfig"]
    #[doc = " (ASC) or a StreamMuxConfig (SMC), contained in a binary buffer. This is"]
    #[doc = " required for MPEG-4 and Raw Packets file format bitstreams as well as for"]
    #[doc = " LATM bitstreams with no in-band SMC. If the transport format is LATM with or"]
    #[doc = " without LOAS, configuration is assumed to be an SMC, for all other file"]
    #[doc = " formats an ASC."]
    #[doc = ""]
    #[doc = " \\param self    AAC decoder handle."]
    #[doc = " \\param conf    Pointer to an unsigned char buffer containing the binary"]
    #[doc = " configuration buffer (either ASC or SMC)."]
    #[doc = " \\param length  Length of the configuration buffer in bytes."]
    #[doc = " \\return        Error code."]
    pub fn aacDecoder_ConfigRaw(
        self_: HANDLE_AACDECODER,
        conf: *mut *mut UCHAR,
        length: *const UINT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief Submit raw ISO base media file format boxes to decoder for parsing"]
    #[doc = " (only some box types are recognized)."]
    #[doc = ""]
    #[doc = " \\param self    AAC decoder handle."]
    #[doc = " \\param buffer  Pointer to an unsigned char buffer containing the binary box"]
    #[doc = " data (including size and type, can be a sequence of multiple boxes)."]
    #[doc = " \\param length  Length of the data in bytes."]
    #[doc = " \\return        Error code."]
    pub fn aacDecoder_RawISOBMFFData(
        self_: HANDLE_AACDECODER,
        buffer: *mut UCHAR,
        length: UINT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief Fill AAC decoder's internal input buffer with bitstream data from the"]
    #[doc = " external input buffer. The function only copies such data as long as the"]
    #[doc = " decoder-internal input buffer is not full. So it grabs whatever it can from"]
    #[doc = " pBuffer and returns information (bytesValid) so that at a subsequent call of"]
    #[doc = " %aacDecoder_Fill(), the right position in pBuffer can be determined to grab"]
    #[doc = " the next data."]
    #[doc = ""]
    #[doc = " \\param self        AAC decoder handle."]
    #[doc = " \\param pBuffer     Pointer to external input buffer."]
    #[doc = " \\param bufferSize  Size of external input buffer. This argument is required"]
    #[doc = " because decoder-internally we need the information to calculate the offset to"]
    #[doc = " pBuffer, where the next available data is, which is then"]
    #[doc = " fed into the decoder-internal buffer (as much as"]
    #[doc = " possible). Our example framework implementation fills the"]
    #[doc = " buffer at pBuffer again, once it contains no available valid bytes anymore"]
    #[doc = " (meaning bytesValid equal 0)."]
    #[doc = " \\param bytesValid  Number of bitstream bytes in the external bitstream buffer"]
    #[doc = " that have not yet been copied into the decoder's internal bitstream buffer by"]
    #[doc = " calling this function. The value is updated according to"]
    #[doc = " the amount of newly copied bytes."]
    #[doc = " \\return            Error code."]
    pub fn aacDecoder_Fill(
        self_: HANDLE_AACDECODER,
        pBuffer: *mut *mut UCHAR,
        bufferSize: *const UINT,
        bytesValid: *mut UINT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief               Decode one audio frame"]
    #[doc = ""]
    #[doc = " \\param self          AAC decoder handle."]
    #[doc = " \\param pTimeData     Pointer to external output buffer where the decoded PCM"]
    #[doc = " samples will be stored into."]
    #[doc = " \\param timeDataSize  Size of external output buffer."]
    #[doc = " \\param flags         Bit field with flags for the decoder: \\n"]
    #[doc = "                      (flags & AACDEC_CONCEAL) == 1: Do concealment. \\n"]
    #[doc = "                      (flags & AACDEC_FLUSH) == 2: Discard input data. Flush"]
    #[doc = " filter banks (output delayed audio). \\n (flags & AACDEC_INTR) == 4: Input"]
    #[doc = " data is discontinuous. Resynchronize any internals as"]
    #[doc = " necessary. \\n (flags & AACDEC_CLRHIST) == 8: Clear all signal delay lines and"]
    #[doc = " history buffers."]
    #[doc = " \\return              Error code."]
    pub fn aacDecoder_DecodeFrame(
        self_: HANDLE_AACDECODER,
        pTimeData: *mut INT_PCM,
        timeDataSize: INT,
        flags: UINT,
    ) -> AAC_DECODER_ERROR;
}
extern "C" {
    #[doc = " \\brief       De-allocate all resources of an AAC decoder instance."]
    #[doc = ""]
    #[doc = " \\param self  AAC decoder handle."]
    #[doc = " \\return      void."]
    pub fn aacDecoder_Close(self_: HANDLE_AACDECODER);
}
extern "C" {
    #[doc = " \\brief       Get CStreamInfo handle from decoder."]
    #[doc = ""]
    #[doc = " \\param self  AAC decoder handle."]
    #[doc = " \\return      Reference to requested CStreamInfo."]
    pub fn aacDecoder_GetStreamInfo(self_: HANDLE_AACDECODER) -> *mut CStreamInfo;
}
extern "C" {
    #[doc = " \\brief       Get decoder library info."]
    #[doc = ""]
    #[doc = " \\param info  Pointer to an allocated LIB_INFO structure."]
    #[doc = " \\return      0 on success."]
    pub fn aacDecoder_GetLibInfo(info: *mut LIB_INFO) -> INT;
}
